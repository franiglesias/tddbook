# TDD y calidad de vida (la tuya)

Ya sea como empleados o freelance vendemos nuestro tiempo y trabajo a empresas y clientes. Una cosa que distingue nuestra profesión de ortas es el hecho de que vendemos trabajo intelectual. Incluso, a veces, trabajo intelectual de alto nivel.

Así que cuidar de nuestra mente e inteligencia parece ser una actividad razonable que deberíamos practicar con frecuencia.

Hay mucha gente en el mundo del desarrollo de software que piensa, o incluso afirma, que hacer testing es duro o caro, y eso sin mencionar el Test Driven Development. Pero lo que queremos demostrar es que TDD es el camino más recomendable si quieres tener una vida más sana en el campo del desarrollo de software.

Pero primero, veamos un par de cuestiones acerca de cómo funciona nuestro cerebro.

## Conocimiento en el mundo, conocimiento en la cabeza

¿Sabes utilizar una puerta? ¿Seguro? ¿Has visto alguna vez una puerta con manual de instrucciones? Yo sí: todas esas que tienen letreros indicando si se debe empujar o tirar.

¿Te has visto alguna vez ante una puerta cerrada sin saber cómo abrirla? Yo sí. De hecho hay montones de ella por ahí.

El caso es que una puerta debería ser algo fácil de usar y no siempre sucede. Cómo se usa una puerta debería ser obvio, ¿no?

¿Y qué tal si hablamos de interruptores? Me refiero a esos paneles de interruptores cuya disposición no está relacionada con la de las luces que controlan. A veces están situados en lugares en donde no se pueden ver las lámparas y necesitas probar varias veces has encontrar la combinación secreta que enciende la luz que quieres.

La relación entre un interruptor y la lámpara que controla debería ser obvia, ¿no?

Cuando hablamos de algo obvio, nos referimos a conocimiento que no deberíamos tener que buscar en nuestra cabeza. El conocimiento está ahí, en el mundo. Sólo tenemos que usarlo mientras hacemos otras cosas. Queremos poder abrir puertas y encender luces sin tener que pensar en ello.

Por eso, cuando nos vemos obligadas a pensar en cosas que deberían ser obvias, estamos desperdiciando parte de nuestro recursos mentales, utilizando espacio en nuestra memoria de trabajo que preferiríamos estar empleando en otros propósitos.

El conocimiento está en el mundo cuando todas las pistas que necesitamos para usar o interactuar con un objeto están presentes en el objeto mismo. Por eso no necesitamos preocuparnos, razonar o recordar cómo utilizarlos. Cuando necesitamos hacerlo, es decir cuando necesitamos razonar o recordar instrucciones, tenemos que poner el conocimiento en nuestra cabeza para poder alcanzar nuestro objetivo.

Por esto, si disponemos de más conocimiento en el mundo cuando ejecutamos una tarea, necesitamos menos conocimiento en nuestra cabeza, dejando espacio libre en ella que podemos usar para pensar mejor acerca de lo que estamos haciendo.

Cuanto menos tengamos que pensar en cómo usar las herramientas, más podemos pensar el lo que estamos haciendo con ellas.

Pero, ¿de cuánto espacio disponemos en nuestra memoria de trabajo?

Bueno…, el caso es que no mucho.

## La capacidad de nuestra memoria de trabajo

Disponemos de una capacidad de almacenamiento prácticamente infinita es nuestra memoria. Piensa en ella como un enorme e inteligente disco duro que puede guardar recuerdos y datos durante años. No se trata de un almacén pasivo. De hecho, reconstruye nuestra memoria para guardar y recuperar cosas. Esto es importante, porque cuando lo hacemos, necesitamos usar nuestra memoria de trabajo para mantener los datos que estamos usando. Muy parecido a un ordenador.

Sin embargo, nuestra memoria de trabajo es bastante diferente de nuestra memoria a largo plazo. Hay quien la llama "memoria a corto plazo" y hay quien "memoria de trabajo". Creo que podemos verla como un procesador, con  algunos registros que pueden almacenar una cantidad limitada de unidades de información llamadas *chunks* mientras trabaja. Los *chunks* pueden tener un tamaño variable, pero son unidades significativas.

¿Puedes recordar un número de teléfono? Me apuesto a que ha agrupado los dígitos de modo que sólo tines dos o tres números que retener.

Esto es porque nuestro procesador puede manejar un número limitado de chunks. Este número es aproximadamente 7 (más o menos dos). Es algo que varía con la edad y entre los individuos, pero es una aproximación muy buena. Por tanto, intentamos ahorrar tantos registros como podemos, agrupando la información en *chunks*, y manteniendo alguno de los registros libre.

¿Qué sucede ti llenamos todos los registros? Pues la precisión y la velocidad al realizar la tarea disminuyen, aumentando los errores. En general, el desempeño es peor si tratamos de mantener muchas cosas en nuestra memoria de trabajo al mismo tiempo.
 
Por supuesto, se trata de una sobre simplificación. Sin embargo, creo que puedes hacerte una idea. Podemos reducir la sobrecarga si ponemos el conocimiento el mundo, en lugar de mantenerlo en nuestra cabeza, con lo que nuestro desempeño será mejor en cualquier tarea.


You can put some knowledge out of the working memory by practice. That’s why when we introduce a new technique, or a new language feature, or a new tool, etc, we need to go slower and we have some more errors in our work. We need time to automate things in our mind while putting knowledge in the world.

In our work we need to manage tasks that cannot be automated, we usually work in tasks that are new every time.

And now, it’s time to return to the main goal of this article. Let’s talk about a developer’s life.

Let’s analyze for a moment what happens when we program without tests…

In fact, we always do tests, but we tend to do manual testing. This is what we call debugging. We use a trial and error process: Does this work? No…? Try again. Yes…? Go ahead.

The process is best reflected in this picture: We try to write code and verify that this code works as we want at the same time we write it, until we think it’s done. After that, we try to verify that the code works as a whole, and, then, we remember that we forgot some details… We deploy, and we discover new details that don’t work, so we need to fix them.

At the end of the day we’ll find ourselves with big headaches and under the impression of having missed something. 

This happens because we try to manage all the information in our head at the same time (remember, it is limited), we overcharge ourselves. The best strategy is to write down goals, subtasks, helping us with these external aids.

For example: a simple endpoint for an API could need a lot of things:

1. A controller action
2. A route to this controller action
3. A use case or command object to perform the action
4. Probably an entity (or more) and the repository
5. The repository DIC definition
5. Maybe a service
6. The service DIC definition
7. A response object

Our memory becomes overcharged. This explains why we feel tired and stressed, and with the feeling that we may have forgotten something, and unsecure about what we are doing or if we have left out something important.

So, let’s take a look at how we would execute the same process, this time with testing at the end.

Well. This looks familiar, but now there are tests at the end of the process. The kind of tests we automate.

The end result is better, because we are more confident about our code thanks to the tests. But we have the same headache at the end of the day. 

Yes, we have been doing the same amount of work, with the same memory overload and with the addition of having to write a bunch of tests, while our brain is screaming: “Hey, dude, work is done! What the heck are you doing?“

In that conditions, maybe our tests are not the best tests in the world…

In fact, we are already tired when we start the testing phase.
This explains why many people think that testing is hard and that it hurts.

So, tests improve our confidence in the code, at the cost of lots of extra work. Our life is not better with tests, even if we sleep better at night…
What’s wrong?

To really improve your life, you should try a different approach. You should do TDD.

This is the TDD cycle: one thing at a time (and to postpone decisions):

* A simple test that fails (don’t write code until you have a test)
* Code to make that simple test to pass (don’t write anything more or less than what is needed)
* Review the code to improve things, like naming, architecture, apply patterns, reduce duplication, but don’t implement anything new keeping the tests in green state.

Here you can see the process from the point of view of our working memory model. When we write the first failing test we are focused on that test. So we don’t want to pay attention to anything out of this. Writing the tests also means that we are putting the knowledge we will need in the world. Our memory is almost free.

Next, we focus on writing the code needed to make the test pass. The knowledge we need is in the test, that happens to be the goal of our task, so it is in the world, not in our head.

We only have to think in a way to make the test pass, so, if it is the first test, we only need to write the more obvious implementation that is possible. Even if that implementation is one as simple as to directly return the value expected by the test. Don’t need to worry about anything else.

And then, once the test has passed, we can take a look at the code and see if we can make some improvements via refactoring. We don’t have to add features. We must keep the test passing while tiding things, removing undesired duplication, etc.

We’ll repeat the cycle till we have the feature fully implemented. We don’t need to write extra tests, we don’t have the risk of forgetting something. Our head doesn’t hurt. We have used our brain to think, avoiding memory overload.

It’s not magic, it’s TDD. Of course, to achieve this needs some training. TDD is an intellectual tool, and tool use needs to be automated. 
Therefore, you should be doing exercises, like katas, both for yourself, both with some colleagues’ help, in a community of practice… whatever fits you or your team. Practice, practice and practice. Once you are able to proceed step by step, you will discover that not only things become easier, but you will be happier and less stressed in the long term.

A final advice:

Store the most of knowledge you need in the world: use a backlog, post-its, write-down a list of tasks, draw schemas, models, concept maps…

Free your head to leave room to work on one thing at a time.

TDD is more than tests. It is to put the knowledge you need in the code (in the world) and free your mind. It is to postpone decisions to the time when you are ready to make them. 

Really, try TDD, your life as developer will improve.
