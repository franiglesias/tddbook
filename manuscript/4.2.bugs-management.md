# Resolviendo bugs con TDD

En nuestro proyecto de lista de tareas hemos desarrollado lo que podríamos llamar el *happy path* de la aplicación. Es decir, hemos supuesto que al crear una tarea la consumidora del API no cometería errores como intentar crear una tarea sin nombre. Otro supuesto es que al marcar una tarea como completada se usarán id de tareas que existan en la lista.

Esto significa que la aplicación puede fallar si no se cumple alguno de estos supuestos. ¿Es esto un bug? En cierto sentido sí, aunque también podemos argumentar que son prestaciones no implementadas.

Cuando desarrollamos usando TDD podemos prevenir muchos defectos debidos a implementaciones con errores. Por ejemplo, imagina que no hemos implementado un método `Task::markComplete` y no tenemos tests cuya ejecución implique esa llamada. El resultado será un *bug*.

Obviamente, si no hemos escrito un test para verificar un comportamiento específico, como podría ser impedir que se puedan crear tareas sin descripción, ese defecto acabará apareciendo.

Se dice que ni el testing ni el TDD nos libran de que un software tenga defectos. Sin embargo, creo que podemos estar muy seguras de que usando TDD los defectos aparecerán en aquellas partes que no estén cubiertas por un test. Considerados así, por tanto, los defectos son más bien circunstancias no previstas o casos no implementados todavía. Esto es interesante y bastante liberador, porque en cierto modo, hace que los defectos del software sean bastante previsibles y manejables, motivados por la falta de definición o, simplemente, por falta de información en el momento del desarrollo. 

Así que vamos a ver cómo trabajaríamos en el caso de que se reporta un bug sobre nuestro proyecto To-do list.

## Defectos en To-do list

Después de un tiempo utilizando nuestra API para generar listas de tareas, vemos que hay algunos defectos. Uno de ellos es que podemos introducir tareas sin descripción, lo que no tiene mucho sentido ya que no nos sirve para saber qué tenemos que hacer.

Este bug es debido a que no controlamos en ningún momento que efectivamente recibimos la descripción de la tarea, es decir, estamos confiando en que el input es siempre correcto. En ese caso, caben dos posibilidades: que el *payload* de la petición al *end point* del POST esté completamente vacía o que el campo `task` venga vacío.

En esta ocasión, el comportamiento del sistema no está especificado para estas circunstancias y no está expresado en tests. En otros casos, el bug es algún tipo de error no cubierto por los tests actuales.

Así que nuestra primera aproximación será crear un test que ponga de manifiesto el bug.

Ahora bien, ¿en dónde nos interesa poner ese test? Vamos a intentar pensar un poco en esto.

Por un lado, los *end points* afectados deberían devolver una respuesta 400 (*Bad Request*) porque en este caso, lo que ocurre es que la *request* está mal construída y el *end point* no la entiende.

Según esto, tendría sentido añadir un test de aceptación. Sin embargo, también tenemos tests unitarios del controlador, que son mucho más rápidos y también nos permitirían comprobar que la respuesta tiene el código adecuado.

Por otro lado, debemos tomar en consideración qué componente se responsabiliza de validar qué cuestiones. 

Así por ejemplo, si la *request* no trae ninguna *payload* o la estructura no incluye los campos requeridos, tiene sentido que el controlador sea el responsable de verificarlo y fallar en cuanto lo detecta. El test tiene sentido a nivel del controlador.

En cambio, si la *request* tiene la estructura correcta y se pueden encontrar los campos requeridos, puede que la validación de sus valores corresponda a capas más internas. Así, por ejemplo, si el valor de `task` en la *payload* es una cadena vacía el controlador puede intentar pasarlo al caso de uso y que sea el constructor de `Task` quien valide si ese valor es aceptable o no. El test, en este caso, sería en el nivel del caso de uso `AddTaskHandler`. 

Esto abre entonces una nueva problemática para el controlador y es gestionar los errores o excepciones que vengan del caso de uso para devolver la respuesta de error adecuada.

Como se puede ver, se plantean un montón de circunstancias que nos obligan a intervenir en distintos niveles de la aplicación.

Un principio que podríamos tratar de seguir es que si falla algo en el nivel de aceptación debería tener un reflejo en el nivel unitario. El primer fallo nos indica que la aplicación tiene un defecto, mientras que el fallo en el nivel unitario nos indicaría el componente que falla.

Así que vamos a ir por partes, atacando cada uno de los problemas.

## Payload inválida

El supuesto que vamos a tratar de resolver es enviar una petición al *end point* que esté mal formada o vacía. En cualquier caso no incluye el campo `task`.

Empezaremos por el test de aceptación y vamos a intentar reproducir el error lanzando una petición al API con una payload inválida.


```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

	// ...
	
    /** @test */
    public function asUserITryToAddTaskWithInvalidPayload(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['bad payload'], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

	// ...
}
```

El test falla porque el *end point* devuelve un error 500 en lugar del error 400 que sería deseable en este caso. ¿Qué podemos hacer ahora?

Pues nos moveremos al nivel del controlador, para ver qué podemos hacer allí al respecto. Y tendremos que escribir otro test caracterizando la misma situación.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }


    // ...

     /** @test */
    public function shouldFailWithBadRequestIfInvalidPayload(): void
    {
        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['invalid payload'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

}

```

Fíjate que he eliminado que se haga alguna expectativa sobre el `mock` del caso de uso. En mi opinión se trata de un test que no aportaría nada en este caso y contribuye a acoplarnos a la implementación. Es cierto que eso ocurre en todos los test del controlador que tenemos hasta ahora, pero no hay razón para aumentar el acoplamiento.

Al ejecutar el test falla porque ya no encuentra el índice `task` cuando lo necesita en `TodoListController`:

```php
    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }
```

Esto forma parte de la lógica del controlador por lo que no vamos a necesitar profundizar más. Si lo arreglamos aquí, habremos resuelto el problema.

Parece bastante claro que tenemos que chequear si la *payload* tiene la estructura correcta y responder en consecuencia:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!isset($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...
}
```

Con el test del controlador pasando, volvemos al de aceptación. Los ejecutamos todos y vemos que también pasan perfectamente.

Y con ello hemos resuelto el *bug*.

## Valores de negocio no válidos

Una cosa es que el *payload* sea incorrecto estructuralmente, validación de la que se tiene que ocupar el controlador. Sin embargo, dado un *payload* estructuralmente válido, en el que el controlador pueda encontrar los valores que necesita, ¿qué ocurre si esos valores no son aceptables según las reglas de negocio?

Lo que ocurre es que la responsabilidad de detectar el problema está en los objetos de dominio, los cuales lanzarán excepciones que tienen que ir subiendo hasta que algún componente pueda gestionarlas.

Por ejemplo, en el caso de `Task`, esperamos que tenga alguna descripción. No ha sido definido en las historias de usuario, pero es algo que damos por hecho. Puede ocurrir, entonces, que la *payload* nos traiga un campo `task` con alguno de estos valores:

* `null`
* Un tipo de dato que no sea `string`
* Un string vacío o demasiado corto
* Un string de longitud suficiente

Los dos primeros puntos son particularmente técnicos. A nivel del controlador podríamos validar que `task` en un `string` y fallar si no es así.

Sin embargo, los dos últimos apuntan a reglas que tiene que definir negocio. Es decir, ¿consideraríamos aceptable una tarea con una descripción de dos caracteres? Es una decisión de negocio. Supongamos que nos dicen que nos basta con un carácter para admitir una cadena como descripción válida de una tarea, así que simplemente tendremos que controlar que no es una cadena vacía.

Esta regla, en todo caso, tendría que estar en el dominio, porque se trata de una regla de negocio. 

Es más discutible la ubicación de las otras dos restricciones, que se pueden resumir en que el sistema no puede aceptar `task` si no es un `string`.

Pero lo mejor es ver esto partiendo de un test, así que vamos a introducir uno. En este caso, para comprobar qué pasa si `task` es `null`:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithABadTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => null], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

    # ...
}
```

Es muy interesante comprobar que este test pasa. Posiblemente, el arreglo del bug anterior ha evitado que nos encontremos con este.

¿Merece la pena dejar este test aquí? Yo diría que no, ya que no hemos tenido que añadir nada en el código. Lo aprovecharé para probar qué ocurriría si enviamos un dato que no sea string, como un número.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithABadTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 12345], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

    # ...
}
```

Este test falla por el siguiente motivo:

```
TypeError : Argument 1 passed to App\TodoList\Application\AddTaskHandler::execute() must be of the type string, int given
```

Es decir. `AddTaskHandler` espera que pasemos un `string` en `execute`, por lo que nunca va a admitir un dato que no lo sea. Esto nos plantea un problema interesante y es si preferiríamos forzar el tipo `string` para la descripción de modo que si viene, como es el caso, un número lo convierta y siga adelante.

En este ejemplo vamos a suponer que no queremos eso, que el tipo ha de ser `string` sí o sí.

Como hemos visto, el fallo se ha producido también en el controlador, al intentar invocar el caso de uso. Por tanto, nos vamos de nuevo al test del controlador.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }

    # ...

    /** @test */
    public function shouldFailWithBadRequestIfInvalidTaskField(): void
    {
        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 12345], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }
}
```

El test del controlador falla de la misma forma que el de aceptación. A continuación implementamos lo necesario para hacerlo pasar.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!isset($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        if (!is_string($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...
}
```

Este cambio hace pasar el test, y es de esperar que también el de aceptación, así que lo comprobamos. Recuerda que es muy importante pasar todos los tests, no sólo el específico para el caso, ya que hay que asegurarse de que los cambios introducidos no alteran el comportamiento actual del sistema.

El test de aceptación pasa también. Ahora tenemos que pensar un par de cosas.

Por un lado, el código que hemos introducido es un poco feo y nos distrae del propósito del controlador. Necesitamos hacer un refactor que despeje un poco las cosas.

Esta es una posible solución:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!$this->isValidPayload($payload)) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...

    private function isValidPayload(array $payload): bool
    {
        return isset($payload['task']) && is_string($payload['task']);
    }
}
```

Es una primera aproximación. Podríamos avanzar más en ella, pero de momento es suficiente.

La otra cuestión es la siguiente. Los tests de aceptación que hemos añadido nos han servido para reproducir los bugs y guiarnos en la solución. Sin embargo, en el nivel unitario del controlador hemos hecho prácticamente el mismo test. Es más, el test de aceptación verifica exactamente el comportamiento que el test del controlador, ya que es éste último el que tiene toda la responsabilidad sobre ese comportamiento.

Esta duplicación no siempre es útil. De hecho, para negocio, a quien interesa el test de aceptación, no le preocupa demasiado el tipo de problemas técnicos que estamos verificando. En cambio, en el nivel unitario este tipo de detalles es más relevante.

Así que en caso de tener tests en el nivel de aceptación que son idénticos a otros en el nivel unitario, es preferible eliminar los de aceptación si no aportan valor a negocio, teniendo cubierta la misma circunstancia en los unitarios.

Así que nosotros vamos a eliminar esos tests antes de continuar.


## Garantizando reglas de dominio

Nuestro siguiente tests verificará que una descripción vacía, aunque sea un `string`, no generará una tarea nueva. Lo pondremos en el test de aceptación:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithAnEmptyTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Task description should not be empty', $body['error']);
    }

    # ...
}

```

Este test ya indica una violación de una regla de negocio. Este es el error que genera:

```
Failed asserting that 201 matches expected 400.
Expected :400
Actual   :201
```

Nos indica que se estarían creando tareas con la descripción vacía como si fuesen válidas. Tenemos que profundizar en la aplicación para ver dónde deberíamos controlar el error.

Así que vamos al controlador. Pero éste no tiene que saber nada de las reglas del negocio ya que está en la capa de Infraestructura. Sin embargo, tiene que encargarse de dar la respuesta HTTP adecuada y eso sólo es posible si el caso de uso le comunica de alguna forma que ha habido problemas.

La mejor forma que tiene de hacerlo es lanzando una excepción que el controlador capturará devolviendo una respuesta adecuada.

De este modo, el test del controlador podría quedar así:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }
    
    # ...
    
    /** @test */
    public function shouldFailWithBadRequestIfTaskDescriptionIsEmpty(): void
    {
        $exceptionMessage = 'Task description should not be empty';
        $exception = new InvalidArgumentException($exceptionMessage);
        
        $this->addTaskHandler
            ->method('execute')
            ->willThrowException($exception)
            ->with('');


        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }
}
```

Como se puede ver, simulamos que el caso de uso lanza una excepción y el test falla porque no se captura y, por tanto, no se devuelve una respuesta adecuada. Para no complicar la solución no voy a crear una excepción de dominio, cosa que haría en un proyecto real.

Hagamos pasar el test.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!$this->isValidPayload($payload)) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        try {
            $this->addTaskHandler->execute($payload['task']);
        } catch (InvalidArgumentException $invalidTaskDescription) {
            return new JsonResponse(['error' => $invalidTaskDescription->getMessage()], Response::HTTP_BAD_REQUEST);
        }

        return new JsonResponse('', Response::HTTP_CREATED);
    }

   # ...
}

```

El test unitario del controlador ha pasado. Sin embargo, el test de aceptación no lo hace. Esto es porque el caso de uso no lo hemos tocado todavía. Tenemos que descender un poco más y hacer un test que pueda fallar para que nos diga qué implementar.

Pero primero, examinemos el código:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class AddTaskHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(string $taskDescription): void
    {
       $id = $this->taskRepository->nextIdentity();

       $task = new Task($id, $taskDescription);

       $this->taskRepository->store($task);
    }
}
```

Como se puede ver, el punto en que se debería lanzar la excepción es cuando se crea una tarea (`Task`), pero no hay razón para que sea el caso de uso quien verifique que `$taskDescription` tiene una longitud suficiente.

En su lugar, tiene sentido que esta lógica esté en `Task`. Al fin y al cabo, el caso de uso no es un lugar para aplicar reglas de negocio, sino para coordinar objetos de dominio que son quienes tienen la responsabilidad de mantenerlas.

Así que tendríamos que ir un poco más adentro y modificar el test de `Task` para que garantice que siempre se construye de forma consistente, con una descripción que tiene al menos un carácter. En caso de que la descripción esté vacía, lanzaremos la excepción.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }
}
```

Ahora quedaría implementarlo.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }
}
```

Esta implementación es suficiente para que pase el test unitario. Veamos si también pasan los tests en los demás niveles. Así es, todos los tests unitarios siguen pasando y también lo hace el test de aceptación.

El test de aceptación que acabamos de introducir lo dejaremos ahí porque tiene significado de negocio. Además, el test del controlador en este caso sólo verifica que éste es capaz de gestionar la excepción lanzada por la capa de dominio, mientras que el test de Task verifica que ésta se tiene que construir con una descripción adecuada.

## Tareas no encontradas

Otro defecto de nuestra aplicación tiene que ver con intentar marcar como completada una tarea que no existe. Actualmente, el *end point* devolverá un error 500, cuando lo correcto sería un 404 indicando que el recurso que se quiere modificar no existe.

El siguiente test de aceptación lo pone de manifiesto:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToMarkNotExistentTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $response = $this->apiMarkTaskCompleted(3);

        self::assertEquals(404, $response->getStatusCode());
    }
    
    # ...
}

```

El resultado es:

```
Failed asserting that 500 matches expected 404.
```

Además de que hay un error en:

```
"Undefined offset: 3" at /application/src/TodoList/Infrastructure/Persistence/FileTaskRepository.php
```

El error de base se produce en el repositorio. Sin embargo, vamos a proceder sistemáticamente. Como hemos visto en el ejemplo anterior, el error puede manifestarse de distintas maneras en las diferentes capas o niveles de la aplicación, por lo que tenemos que ir paso por paso, decidir si ese error tiene que manifestarse de algún modo e implementar el comportamiento necesario.

El controlador, como ya hemos visto anteriormente, es responsable de interpretar el problema y expresarlo con un error 404 en la respuesta. Por tanto, espera que el caso de uso le comunique eso con una excepción. En la práctica, significa que ese controlador tiene que reaccionar a una excepción determinada que lanzará o relanzará el caso de uso.

Así que expresamos eso en un test.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldFailWithNotFoundIdCompletingNotExistentTask(): void
    {
        $exceptionMessage = 'Task 3 doesn\'t exist';
        $exception = new OutOfBoundsException($exceptionMessage);

        $this->markTaskCompletedHandler
            ->method('execute')
            ->willThrowException($exception);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->markTaskCompleted(self::COMPLETED_TASK_ID, $request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }

}
```

Como era de esperar, el test del controlador fallará porque no se captura la excepción simulada en el *mock*. Nos toca implementar el código para hacerlo:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    # ...
    
    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);
        } catch (OutOfBoundsException $taskNotFound) {
            return new JsonResponse(['error' => $taskNotFound->getMessage()], Response::HTTP_NOT_FOUND);
        }

        return new JsonResponse('', Response::HTTP_OK);
    }

    # ...
}
```

Dado que ahora el test pasa en el controlador, volvemos al nivel de aceptación. Este nivel todavía falla porque, de hecho, no se lanza realmente ninguna excepción en el flujo de esta acción.

Necesitamos ir un poco más adentro.

Si examinamos la capa de Aplicación, el caso de uso tiene poco que hacer. Al igual que en el problema anterior, su trabajo es delegar en objetos de dominio, por lo que son estos los que deben fallar. Como he señalado antes, estoy usando excepciones genéricas, pero en proyectos reales usaríamos también excepciones del dominio en distintos niveles. Por ejemplo, una `TaskNotFound` que perfectamente podría extender de `OutOfBoundsException`.

Así que no haremos nada en el caso de uso, pero observamos que el responsable de decir que una tarea no existe será el repositorio. La primera línea del método `execute` es clara.

```php
namespace App\TodoList\Application;


use App\TodoList\Domain\TaskRepository;

class MarkTaskCompletedHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, bool $completed): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        if ($completed) {
            $task->markCompleted();
        }

        $this->taskRepository->store($task);
    }
}
```

No merece la pena escribir un test que simule que el repositorio lanza una excepción y el caso de uso no hace nada. Si el caso de uso capturase excepciones que vienen de un nivel más interno para relanzarlas como una excepción distinta, una técnica que podríamos denominar de *anidado de excepciones*, entonces sí lo haríamos para verificar eso.

Por tanto, nos vamos al nivel del repositorio y hacemos un test:

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;
use Symfony\Component\DependencyInjection\Exception\OutOfBoundsException;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    # ...
    
    /** @test */
    public function shouldFailIfTaskNotFound(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        $this->expectException(OutOfBoundsException::class);
        $this->taskRepository->retrieve(3);
    }
}
```

El test falla puesto que no se lanza la excepción. Así que vamos al código de producción:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use OutOfBoundsException;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    # ...
    
    public function retrieve(int $taskId): Task
    {
        $tasks = $this->findAll();

        if (!isset($tasks[$taskId])) {
            throw new OutOfBoundsException(
                sprintf('Task %s doesn\'t exist', $taskId)
            );
        }

        return $tasks[$taskId];
    }

    # ...
}
```

Con esta sencilla solución hacemos pasar el test. Ejecutamos de nuevo el test de aceptación para ver si el problema está resuelto.

## Resolviendo defectos

Una conclusión interesante sobre lo que acabamos de hacer es que, en realidad, resolver bugs no es más que implementar un comportamiento inexistente en el software. En este contexto, prefiero usar el término *defecto* en lugar de *bug*.

Es más, se podría argumentar que este capítulo más que tratar de resolución de *bugs*, trata de añadir características al software que se habían dejado atrás de manera consciente o no. En la vida real, este tipo de cosas se suele reportar como *bug*, aunque nosotros sepamos que es una *feature* no desarrollada todavía o que no tuvimos en cuenta en su momento.

De hecho, al desarrollar el software usando TDD normalmente evitamos el tipo de defectos que se asocia habitualmente con *bugs*, como podría ser un problema de tipado o algún despiste en el código que el lenguaje, por la razón que sea, permita que pase desapercibido.

En cualquier caso, el procedimiento es más o menos el siguiente:

* Lo primero es reproducir el *bug* mediante un test en el nivel más externo posible. Lo más seguro es que se manifieste en el test de aceptación y es lo esperable si es un problema detectado por las usuarias. Pero eso puede depender del contexto también.
* Seguidamente, vamos al siguiente nivel de la aplicación, intentando reproducir el mismo *bug* con un test unitario. Habrá niveles en que esto no sea posible y el test pase. Como hemos visto en el último ejemplo, la manifestación del *bug* en cada nivel puede ser diferente o puede no darse incluso. Si no podemos demostrar el *bug* en ese nivel, nos vamos al siguiente.
* En cada nivel, implementamos código para hacer que el test que demuestra el *bug* pase. Una vez que los tests de ese nivel están en verde, volvemos al test de aceptación.
* Si el test de aceptación continúa sin pasar, tendremos que ir un nivel más adentro en la aplicación, crear un test que describa el *bug* y resolverlo. Después de eso, volvemos al nivel de aceptación hasta que el test vuelva a pasar.
* En el momento en que el test de aceptación pase, es que ya está resuelto el defecto.

