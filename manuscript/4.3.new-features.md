# Introducción de nuevas características

En el capítulo anterior comentábamos que desde el punto del desarrollo basado en TDD los defectos pueden considerarse casi como *features* no definidas inicialmente. Otra forma de verlo es que son features cuando nos las piden explícitamente y son defecto cuando van implícitas en una feature.

Es decir, cuando decimos que queremos poder marchar una tarea como completada, por seguir con nuestro proyecto de lista de tareas, se asume que debería evitarse que el sistema se rompa si intentamos marcar una tarea inexistente. Por eso diríamos que esa feature tenía un defecto y es lo que hemos arreglado en el capítulo anterior.

Pero en este capítulo vamos a tratar sobre cómo añadir nuevas prestaciones a un software existente utilizando una aproximación TDD. Y, como cabe esperar, en realidad no vamos a introducir cambios en nuestra metodología. Seguiremos empezando con un test de aceptación y profundizando en la aplicación y los cambios necesarios.

Con todo se trata de un escenario distinto. Un nuevo comportamiento puede requerir modificar unidades de software existentes y necesitamos que los cambios no rompan funcionalidad ya creada.

## Nueva historia de usuario

La siguiente petición de negocio es permitir editar una tarea existente.

### US-4

* As a user
* I want to modify a existing task in the list
* So that, I can express my ideas better

Inicialmente esta historia requiere crear un nuevo endpoint con el que cambiar la información de una tarea.

```
PUT /api/todo/{taskId}
```

Si nuestra aplicación tiene un front-end es posible que necesitemos un endpoint para recuperar la información de la tarea que queremos editar, a fin de poder rellenar el formulario con los datos actuales. En ese caso, sería:

```
GET /api/todo/{taskId}
```

En cualquier caso, el procedimiento será el mismo: empezaremos creando un test de aceptación, iniciando el proceso de desarrollo. Lo que sí nos encontraremos es que algunos componentes necesarios están ya creados.


```php
<?php

declare(strict_types=1);

namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    public function asUserIWantToModifyAnExistingTask(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $this->client->request(
            'PUT',
            '/api/todo/2',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write production code to make the test pass'], JSON_THROW_ON_ERROR)
        );

        $putResponse = $this->client->getResponse();
        
        self::assertEquals(204, $putResponse->getStatusCode());

        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write production code to make the test pass',
            ],
            $response
        );
    }
    
    # ...
}
```

Así que ejecutamos el test para ver qué nos dice. Como era de esperar, el endpoint no se puede encontrar porque no tenemos la ruta, así que empezamos por definirla.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']

api_get_task_list:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
  methods: ['GET']

api_mark_task_completed:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
  methods: ['PATCH']

api_edit_task:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask
  methods: ['PUT']
```

Al volver a lanzar el test tras este cambio, nos indicará que no una acción en el controlador para responder a esta ruta.

```
"The controller for URI "/api/todo/2" is not callable. Expected method "modifyTask"
```

Así que tendremos que añadir una nueva acción vacía.

```php
<?php

declare(strict_types=1);

namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    # ...
    
    public function modifyTask(int $taskId, Request $request): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    # ...
}
```

En la nueva ejecución del test, el error será:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask"
```

Lo que nos dice que tenemos que entrar al nivel unitario para implementar esta acción en el controlador. Todo este ciclo te sonará porque es lo que hemos estado haciendo en toda esta parte del libro.

Pero lo cierto es que esta rutina es algo positivo. En cada momento siempre tenemos una tarea concreta que afrontar, ya sea crear un test, ya sea código de producción, y no tenemos que preocuparnos de ninguna otra cosa. El test de aceptación nos va diciendo qué hacer, y en cada nivel sólo tenemos que pensar en ese componente concreto.

A nosotras ahora nos toca implementar el controlador. Como ya sabemos, en esta fase tenemos que diseñar. Básicamente es una acción similar a la de añadir una tarea, pero en este caso recibimos el id de la tarea que vamos a cambiar y su nueva descripción.

Necesitaremos un caso de uso que expresa esta intención de las usuarias al que le pasaremos los dos datos que necesitamos. Si todo va como es debido, devolvemos la respuesta 204 (no content).

Añadimos un test que recoge todo esto:

```php
<?php

declare(strict_types=1);

namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Infrastructure\EntryPoint\Api\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private const TASK_ID = 1;

    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->updateTaskHandler = $this->createMock(UpdateTaskHandler::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler,
            $this->updateTaskHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldModifyATask(): void
    {
        $this->updateTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_ID, self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->modifyTask(self::TASK_ID,$request);

        self::assertEquals(204, $response->getStatusCode());
    }

    # ...
}
```

Si ejecutamos el test nos pedirá crear el caso de uso `UpdateTaskHandler`.

```php
<?php
declare (strict_types=1);

namespace App\TodoList\Application;

class UpdateTaskHandler
{
}
```

Y seguidamente nos pedirá introducir el método `execute`.

```php
<?php
declare (strict_types=1);

namespace App\TodoList\Application;

class UpdateTaskHandler
{
    public function execute()
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Una vez que tenemos eso ya nos vuelve a pedir implementar la acción del controlador. Así que vamos a ello:

```php
<?php

declare(strict_types=1);

namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler,
        UpdateTaskHandler $updateTaskHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
        $this->updateTaskHandler = $updateTaskHandler;
    }

    # ...

    public function modifyTask(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->updateTaskHandler->execute($taskId, $payload['task']);

        return new JsonResponse('', Response::HTTP_NO_CONTENT);
    }

    # ...
}
```

Y el test unitario del controlador ya pasa. Si volvemos al test de aceptación, como corresponde ahora, nos dirá que es lo que tenemos que hacer a continuación:

```
RuntimeException: "Implement App\TodoList\Application\UpdateTaskHandler::execute"
```

Así que nos toca meternos en la capa de Aplicación. De nuevo, tenemos que diseñar este nivel, que nos plantea un problema interesante. 

En principio hemos definido que lo que se puede cambiar en la tarea es su descripción, por lo que esta acción tiene que respetar el estado actual del flag de completado. Así que queremos obtener la tarea guardada, modificar su descripción y guardarla.

Por tanto, pediremos la tarea al repositorio, la cambiaremos y la guardaremos de nuevo.

```php
<?php
declare (strict_types=1);

namespace App\Tests\TodoList\Application;

use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class UpdateTaskHandlerTest extends TestCase
{

    private const TASK_ID = 1;

    public function testShouldUpdateATask(): void
    {
        $task = new Task(self::TASK_ID, 'Task Description');
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::TASK_ID)
            ->willReturn($task);
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with(new Task(self::TASK_ID, 'New Task Description'));

        $updateTaskHandler = new UpdateTaskHandler($taskRepository);

        $updateTaskHandler->execute(self::TASK_ID, 'New Task Description');
    }
}
```

Cuando ejecutamos el test, nos pedirá implementar el caso de uso, puesto que el repositorio ya está definido con anterioridad.

La implementación seguramente nos forzará a introducir algún nuevo método en Task, de modo que se pueda actualizar la descripción. Esta implementación, por ejemplo:

```php
<?php
declare (strict_types=1);

namespace App\TodoList\Application;

use App\TodoList\Domain\TaskRepository;

class UpdateTaskHandler
{

    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, string $newTaskDescription): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        $task->updateDescription($newTaskDescription);

        $this->taskRepository->store($task);
    }
}
```

He elegido esta implementación para simplificar, sin embargo, a medida que hago esta prueba se me ocurren algunas ideas que podrían ser interesantes en un caso de uso realista, como podría ser aplicar cierta inmutabilidad. Es decir, en lugar de actualizar el objeto Task, crearíamos uno nuevo con nuevos valores.

Pero dejaremos estos refinamientos para otra ocasión. Si ejecutamos el test, nos dirá que Task carece del método `updateDescription`, que tendremos que desarrollar con ayuda de un test unitario.

```php
<?php

declare(strict_types=1);

namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldUpdateDescription(): void
    {
        $expected = '[ ] 1. New Task Description';
        $task = new Task(1, 'Task Description');
        $task->updateDescription('New Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

}
```

Para hacer pasar el test tenemos que introducir el método.

```php
<?php

declare(strict_types=1);

namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        $this->description = $newTaskDescription;
    }
}
```

El test pasa, pero nos hemos dado cuenta un problema. Hace nada hemos implementado una validación para impedir que `Task::description` pueda ser una cadena vacía. Para asegurar que cumplimos esta regla de negocio, deberíamos introducir otro test que lo verifique e implementar la respuesta que queramos dar a este caso.

Sin embargo esto no lo hemos cubierto en el nivel de aceptación o en el del controlador. ¿Qué deberíamos hacer entonces? ¿Resolverlo ahora y añadir tests en los otros niveles después o esperar y añadir esa protección en una nueva iteración?

Personalmente creo que la mejor respuesta es tomar nota de esto y resolverlo en un nuevo ciclo. Es importante centrarnos ahora en la característica que estamos desarrollando y terminar este ciclo.

Por tanto, al hacer pasar el test unitario de Task, volvemos primero al test de `UpdateTaskHandler` y comprobamos si ya pasa, cosa que ocurre.

Y con este nivel en verde, probamos de nuevo en el de aceptación, que también pasa sin más problemas.

El resultado es que la nueva historia está implementada, aunque como hemos descubierto necesitamos hacer una iteración para prevenir el problema de intentar cambiar las descripción de una historia con un valor no válido.

¿Lo hubiésemos podido prevenir antes? Puede ser, sin embargo, igualmente necesitaríamos introducir tests en los distintos niveles, al igual que hicimos en el capítulo anterior. El valor de usar una disciplina como TDD es justamente desarrollar una serie de hábitos de pensamiento y una cierta automatización.

