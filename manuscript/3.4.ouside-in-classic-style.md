# *Outside-in* TDD clásico

Es posible seguir una metodología *outside-in* mientras mantenemos el ciclo de TDD clásico. Como ya sabrás, en esta aproximación el diseño se aplica durante la fase de refactor, por lo que, una vez que hemos desarrollado una versión tosca de la funcionalidad deseada, vamos identificando responsabilidades y extrayéndolas a diferentes objetos con los que vamos componiendo el sistema.

En las katas de estilo clásico que hemos presentado en la segunda parte del libro no hemos llegado a esta fase de extracción a colaboradores, aunque lo hemos sugerido varias veces, y sería algo perfectamente posible. De hecho, es un ejercicio recomendable.

Sin embargo, cuando hablamos de *outside-in* es frecuente que pensemos más bien en proyectos más complejos que los problemas propuestos en las katas. Es decir, el desarrollo de un producto de software real visto desde el punto de vista de sus consumidores.

Nuestro ejemplo de backend de aplicación de lista de tareas estaría en esta categoría. En el capítulo anterior hemos desarrollado el proyecto usando el enfoque *mockista*, cuya característica principal es que partimos de un test de aceptación y vamos *entrando* en cada componente de la aplicación, que desarrollamos con la ayuda de un test unitario, *mockeando* los componentes más internos que aún no hemos desarrollado.

En TDD clásico con frecuencia se hace un diseño *up-front* para tener una idea de los componentes necesarios y luego se desarrolla cada uno de ellos, integrándose después.

Pero *outside-in* clásico es un poco diferente. Empezaríamos también con un test en el nivel de aceptación y con el fin de escribir la lógica que lo hace pasar. En las fases de refactor comenzaríamos a extraer objetos capaces de hacerse cargo de las diversas responsabilidades identificadas.

![El ciclo outside-in clasicista](images/print/classic-cycle.jpeg)


Para este ejemplo escribiremos una nueva versión de nuestra aplicación de lista de tareas, esta vez en Ruby. El *framework* HTTP será Sinatra y el *framework* de testing RSpec.

## Planteando el problema

Nuestro punto de partida será igualmente un test de aceptación como consumidoras de la API. En cierto modo, podríamos considerar el sistema como un gran *objeto* con el que nos comunicamos mediante *request* a sus *end points*.

Al tratarse de TDD clásico no usaremos *mocks*, salvo si necesitamos definir un límite de arquitectura. Obviamente para definir este tipo de cosas necesitamos tener algún mínimo de diseño *up-front*, así que esperamos que en algún momento tendremos casos de uso, entidades de dominio y repositorios.

El límite de arquitectura en nuestro ejemplo será el repositorio. Como todavía no vamos a definir cuál es la tecnología concreta de persistencia, en su momento lo *mockearemos*. Después veremos cómo desarrollar una implementación. 

I> Otros ejemplos de límites de arquitectura podría ser todo lo que tiene que ver con fechas y horas, así como la aleatoriedad, el acceso a servicios remotos, etc. En TDD clásico utilizaríamos dobles para abstraerlos.

### Poniendo en marcha el desarrollo

Mi primera propuesta de test es la siguiente:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

Este test intenta instanciar un objeto `TodoListApp`, que es la clase en la que definiremos la aplicación `Sinatra` que responderá en primera instancia. Requiere instalar `rspec`, si no lo tenemos ya. Y fallará con este error:

```
     NameError:
       uninitialized constant TodoListApp
     # ./spec/todo_list_acceptance_spec.rb:10:in `block (2 levels) in <top (required)>'
```

Que nos indica que no tenemos la clase definida en ningún sitio. Para hacerlo pasar, introduciré la clase en el mismo archivo del test y cuando consiga ponerlo en verde, lo moveré a su ubicación.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

class TodoListApp

end

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

Esto es suficiente para hacer pasar el test, por lo que voy a hacer el refactor más obvio, que es mover `TodoListApp` a un lugar adecuado en el proyecto.

A> Recuerda que, en TDD clásico, el refactor siempre se debe hacer con todos los tests existentes en verde.

La fase de refactor es la fase en la que tomamos decisiones de diseño en el enfoque clásico. Los controladores pertenecen a la capa de infrastructura, por lo que será allí donde coloque esta clase. Con eso, el test queda así:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end

```

Y verificamos que sigue pasando.

Para el siguiente punto necesito hacer un salto un poco más grande y preparar el cliente que ejecutará las *requests* contra los *end points*. Usando rack-test, puedo crear un cliente del API. Puesto que estoy en verde, voy a introducirlo e iniciarlo. Tendremos que instalar `rack-test` primero.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )
    
  end
end
```

Este refactor no cambia el resultado del test, así que vamos bastante bien.

Ahora vamos a asegurarnos de que podemos hacer una llamada `POST /api/todo` y que alguien nos responde.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

  end
end
```

Ahora el test falla, porque la aplicación no es capaz de enrutar la llamada a ningún método. Es el momento de implementar algo en `TodoListApp` hasta lograr hacer pasar el test. Esto requerirá introducir e instalar `sinatra`.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base

end
```

Lo cierto es que basta con esto para que el test pase ya que no estamos haciendo ninguna expectativa sobre la respuesta. Necesitamos un poco más de resolución para obligarnos a implementar una acción asociada al *end point*, para lo cual hacemos que el test sea más preciso y explícito:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

    expect(@client.last_response.status).to eq(201)
  end
end
```

Y este test, que ya es un *test de verdad*, nos muestra que no se encuentra la ruta deseada:

```
  1) As a user I want to add a new task to the list
     Failure/Error: expect(@client.last_response.status).to eq(201)

       expected: 201
            got: 404
```

Con lo que ya podemos implementar una acción que responda.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  post '/api/todo' do
    [201]
  end
end
```

Ahora hemos hecho pasar el test, devolviendo una respuesta fija, y ya tenemos la seguridad de que nuestra aplicación está respondiendo al *end point*. Sería el momento de introducir la llamada con su *payload*, que será la descripción de la nueva tarea.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

  RSpec.describe 'As a user I want to' do

    it "add a new task to the list" do
      todo_application = TodoListApp.new

      @client = Rack::Test::Session.new(
        Rack::MockSession.new(
          todo_application
        )
      )

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

El test no añade nueva información. Si queremos progresar en el desarrollo necesitaremos introducir otro test que cuestione la implementación actual, obligando a hacer un cambio en la dirección de conseguir aquello que se espera que haga el test.

Este *end point* sirve para crear tareas y guardarlas en la lista, lo que quiere decir que produce un efecto (*side effect*) en el sistema. Es un comando y no ofrece ninguna respuesta. Para testarlo tenemos que comprobar el efecto verificando que en algún lugar hay una tarea creada.

Una posibilidad es asumir que la tarea se persistirá en un `TaskRepository`, que sería un colaborador de `TodoListApp`. Los repositorios son objetos en los límites de arquitectura y se basan en una tecnología concreta. Esto presupone un cierto nivel de diseño previo, pero creo que es un compromiso aceptable dentro del enfoque clásico.

Esto implica modifica la forma en que se instancia `TodoListApp`, de modo que podamos pasarle colaboradores. Así que antes de nada, vamos a refactorizar el test de modo que la creación de nuevos ejemplos sea más fácil y el test más expresivo.

Quedaría algo así:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

Con este rediseño el test sigue pasando. Ahora, tenemos que introducir un doble del repositorio. Lo mínimo necesario para forzarnos a crear algo es:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

Con lo que tendríamos que introducir la definición de la clase. De momento, lo haremos en el mismo archivo.

```ruby

# ...

class TaskRepository
  
end

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

# ...

```

Y se lo pasamos a `TodoListApp` como parámetro de construcción.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

class TaskRepository

end

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    [201]
  end
end
```

En principio estos cambios no afectan al resultado del test.  Así que vamos a mover `TaskRepository` a su sitio, en la capa de dominio.

A continuación, necesitamos definir el efecto que esperamos obtener, lo cual hacemos fijando una expectativa sobre el mensaje que vamos a enviar a task repository.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
  require_relative '../src/domain/task_repository'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do

      expect(@task_repository)
        .to receive(:store)
              .with(instance_of(Task))

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
end
```

El test falla inicialmente porque hemos introducido `Task`, así que lo añadimos ya en su ubicación en la capa de dominio, porque lo necesitaremos enseguida. Al hacerlo, conseguimos que el test falle por el motivo adecuado:

```
1) As a user I want to add a new task to the list
   Failure/Error:
     expect(@task_repository)
       .to receive(:store)
             .with(instance_of(Task))

     (Double TaskRepository).store(an_instance_of(Task))
         expected: 1 time with arguments: (an_instance_of(Task))
         received: 0 times
```

Añadiendo este código en `TodoListApp`, hacemos que pase el test.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new
    @task_repository.store(task)
    [201]
  end
end
```

Ahora necesitamos que un nuevo test nos pida implementar que se instancie una `Task` con los valores deseados. Esto es, queremos que `Task` se inicie con el id `1` y la descripción que le pasamos. Para que el test funcione tenemos que implementar una inicialización en `Task`, que aún no tenemos y alguna forma de comparar objetos `Task`.

A> En Ruby, dos objetos son iguales si tienen el mismo identificador interno de objeto, por lo que la `Task` que creemos en el test como esperada y la que se genere en el código de producción nunca serán iguales.Para verificarlo tenemos varias opciones, aunque una de las más sencillas es introducir un *matcher* en el test que nos permita hacer alguna comparación.

Por otro lado, tenemos que implementar alguna manera de inicializar `Task`. Esta creación puede ser cubierta por el propio test de aceptación. Otro modo de hacerlo sería desarrollando `Task` con un test unitario, pero la verdad es que, de momento, no lo veo necesario.

Al introducir esto en el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Empezará a fallar, por lo que tenemos que implementar la inicialización:

```ruby
class Task
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

El test falla ahora porque en el `TodoListApp` no estamos inicializando bien `Task` ya que no le pasábamos argumentos. Con este pequeño cambio, el test ya pasa.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new 1, 'Write a test that fails'
    @task_repository.store(task)
    [201]
  end
end
```

Se puede decir que aquí estamos usando constantes para satisfacer el test, por lo que tenemos que evolucionar el código y obtener una implementación más flexible. Empezaré con un pequeño refactor que ponga de manifiesto lo que tenemos que lograr a continuación.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task_id = 1
    task_description = 'Write a test that fails'
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Así de simple, tenemos que obtener valores para las variables que acabamos de introducir. Pero ahora mismo no lo estamos comprobando. Es el momento de introducir un *matcher*.

```ruby
RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end
```

Para usarlo, cambiaremos el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

En este momento el test no pasará porque `Task` no expone métodos para acceder a sus propiedades, por lo que añadiremos `attr_reader`:

```ruby
class Task
  attr_reader :description, :id
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

Y con esto el test pasa.

`task_description` viene en la *payload* de la *request*. Puesto que ya está definida en el test ahora mismo podríamos simplemente usarla.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']
    
    task_id = 1
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

En cuanto al id de `task`, necesitaremos un generador de identidades. En nuestro diseño hemos puesto esta responsabilidad en `TaskRepository`, que tendría un método *next_id*. En este caso, tendremos que especificarlo en el test mediante un stub.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Tal y como está el código de producción el test pasa, por lo que no nos dice qué tendríamos que hacer a continuación, así que voy a hacer una pequeña trampa y forzar un fallo del test:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = 0
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Ahora sí tiene sentido introducir la llamada a `next_id`:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = @task_repository.next_id
	
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

## Extracción del caso de uso

Ahora el test ya pasa y podríamos decir que la implementación del *end point* está completa. Sin embargo, tenemos varios problemas:

* `TaskRepository` es un *mock*. Sabemos que interfaz debería tener, pero no tenemos ninguna implementación concreta que pueda funcionar en producción.
* En el controlador hay un montón de lógica de negocio que no debería estar ahí.
* De hecho tenemos objetos de dominio en el controlador: `Task` y `TaskRepostory`.

En resumen, ahora mismo, el controlador está haciendo más cosas de las debidas. Además de su tarea como controlador, que es gestionar la *request* que viene del exterior, está haciendo tareas de la capa de aplicación, coordinando objetos del dominio.

Por tanto, tendríamos que extraer esta parte de la implementación a un nuevo objeto, que será el caso de uso `AddTaskHandler`.

Lo primero que hago es extraer la funcionalidad a un método privado

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private
  
  def add_task(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Crearé una clase `AddTaskHandler` en la capa de aplicación que encapsule la misma funcionalidad:

```ruby
class AddTaskHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Y reemplazo la implementación del método por una llamada:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private

  def add_task(task_description)
    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
  end
end
```

Hago un *inline* del método:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
    [201]
  end
end
```

Y refactorizo un poco la solución, moviendo la inicialización al constructor y eliminando alguna variable temporal:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
    @add_task_handler = AddTaskHandler.new @task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    
    @add_task_handler.execute payload['task']
    
    [201]
  end
end
```

El siguiente paso es inyectar la dependencia de `AddTaskHandler` en lugar de la del repositorio. Para ello cambio primero el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)
  @add_task_handler = AddTaskHandler.new @task_repository
  TodoListApp.new @add_task_handler
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Esto hará que el test falle porque el código de producción sigue esperando al repositorio como dependencia, así que lo cambiamos de este modo:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end
end
```

Y ya tenemos esta parte resuelta.

## Implementando un repositorio

Para arrancar el desarrollo hemos empezado con un `TaskRepository` que es un *mock*. Hemos introducido una clase vacía para poder doblarla, pero esta version *real* no puede recibir mensajes siquiera. Esto ha sido una licencia que me he permitido para no empezar a desarrollar *desde dentro*, creando componentes de la capa de dominio como este repositorio, antes de saber cómo iban a ser usados.

El repositorio es uno de esos objetos que viven en el límite de arquitectura, por así decir, por lo que es bastante aceptable usar un doble. Sin embargo, ahora vamos a tratar de implementar una versión que pueda servirnos para testear.

I> En Ruby no tenemos el concepto de interfaz explícita. Esto no es un obstáculo para tener diversas implementaciones de repositorio que podamos usar en distintos entornos. Así, por ejemplo, para tests unitarios podríamos usar un repositorio en memoria, mientras que para pruebas de aceptación es posible que necesitemos una persistencia más duradera, aunque en este ejemplo sólo necesitaremos la implementación en memoria.

Esto supone un pequeño problema si consideramos que `TaskRepository` es un objeto del dominio, por lo que no queremos tener implementaciones concretas en esta capa. Una forma sencilla de hacerlo es mediante composición: en dominio tendríamos una clase `TaskRepository` que simplemente delegaría en la implementación concreta que inyectemos. Este es el enfoque que vamos a adoptar en este caso, implementando las versiones del repositorio que puedan ser necesarias a partir de un test unitario extrayendo las implementaciones a partir de una genérica.

En esta ocasión empezamos por la capacidad del repositorio de atender un mensaje `next_id`, que debería ser 1 cuando el repositorio está vacío.

```ruby
require 'rspec'

describe 'TaskRepository' do
    it 'should provide empty collection of tasks' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end
end
```

Este método aún no existe y el test fallará. Implementamos una versión inicial.

```ruby
class TaskRepository
  def next_id
    1
  end
end
```

Con el test en verde, vamos a hacer un refactor. `next_id `debería proporcionarnos un número que es el resultado de sumar uno a la cantidad de tareas almacenada. Así que vamos a representar esto en código primero.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end
  def next_id
    @tasks.count + 1
  end
end
```

Lo suyo sería poder añadir elementos y ver si las cosas realmente funcionan, así que vamos a permitir que el repositorio se pueda inicializar con algún contenido.

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end
end
```

Con esto, podemos testear que si iniciamos el repositorio con algún elemento nos devuelve el identificador correcto. Por ejemplo, así:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'
      
      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Esto ya debería ser suficiente para fiarnos de `next_id`. Puede que estés pensando que la generación de identidades con este algoritmo no es precisamente robusta, pero de momento nos llega para el ejemplo. En cualquier caso, podríamos implementar cualquier otra estrategia.

Ahora podríamos usar `next_id` como una manera indirecta de saber si hemos añadido tareas en el repositorio, por lo que ya podemos testear el método `store`.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'

      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end


    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

De momento, el test falla porque no tenemos un método que atienda el mensaje `store`, así que lo añadimos es implementamos la solución más simple:

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Que, por lo demás, es suficiente para hacer pasar el test. El último test se superpone al anterior test de `next_id`, así que lo vamos a quitar.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Y también podemos quitar la inicialización, ya que no la necesitamos realmente.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Podríamos asegurarnos de que podemos introducir más tareas:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end

    it 'should add several tasks' do
      task_repository = TaskRepository.new

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

      expect(task_repository.next_id).to eq(4)
    end
end
```

Puesto que queremos separar la tecnología concreta de persistencia, usaré estos tests para extraer un repositorio en memoria. Nos queda así:

```ruby
require_relative '../infrastructure/persistence/memory_storage'

class TaskRepository
  def initialize
    @storage = MemoryStorage.new
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end
end
```

Ahora podemos inyectarlo, para ello modificamos primero el test:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
  before() do
    @task_repository = TaskRepository.new
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(@task_repository.next_id, 'Task Description')
    @task_repository.store Task.new(@task_repository.next_id, 'Another Task')
    @task_repository.store Task.new(@task_repository.next_id, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end
end
```

Y ahora que sólo tenemos un lugar para inicializar el repositorio...

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end
	
  # ...
end
```

El test fallará, pero sólo es necesario hacer este cambio:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

Con el cual tenemos un `TaskRepository` que podremos configurar para usar distintas tecnologías de persistencia y que podríamos empezar a usar en nuestro test de aceptación.

Un cambio posible es este, aunque luego seguiremos evolucionándolo:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end
end
```

## Obtener la lista de las tareas

Una vez que podemos añadir tareas, sería interesante poder acceder a ellas. Nuestro siguiente test de aceptación describiría esta acción, introduciendo una o más tareas y obteniendo una lista con todas las que tengamos.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)
    
    expected_list = [
      '[ ] 1. Write a test that fails'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

Lanzamos este test y vemos que falla, ya que no hay controlador que se encargue de esta ruta. 

```
  1) As a user I want to get a list with all the tasks I've introduced
     Failure/Error: expect(@client.last_response.status).to eq(200)

       expected: 200
            got: 404
````

Así que añadimos uno:

```ruby
  # frozen_string_literal: true

  require 'sinatra'
  require_relative '../../domain/task'
  require_relative '../../domain/task_repository'
  require_relative '../../application/add_task_handler'

  class TodoListApp < Sinatra::Base
    def initialize(add_task_handler)
      @add_task_handler = add_task_handler
    end

    post '/api/todo' do
      payload = JSON.parse request.body.read.to_s

      @add_task_handler.execute payload['task']

      [201]
    end

    get '/api/todo' do
      
    end

  end
```

Esta vez el error es que no se devuelve nada. Podemos arreglarlo fácilmente con esta implementación constante:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end

end
```

Por supuesto, lo suyo sería obtener las tareas del repositorio y generar la respuesta a partir de ahí. Para ello vamos a modificar un poco el test, introduciendo una tarea más y esperando una lista más larga en consecuencia.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

El test fallará porque no coinciden la lista generada y la esperada. Para hacerlo pasar necesitaremos volver a inyectar el repositorio, de modo que podamos recuperar las tareas guardadas.

De momento, podemos hacerlo en el test, pero antes tendríamos que anular este segundo test para volver a verde y hacer los cambios que necesitamos. Este es el test que quedaría:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    # @client.post '/api/todo',
    #              { task: 'Write Production code that makes the test pass' }.to_json,
    #              { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      # '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

El código de producción:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end
end
```

Ahora nos encontramos un par de problemas:

* No tenemos un método en el repositorio para obtener las tareas
* Tenemos que gestionar la transformación de `Task` en su representación

Personalmente creo que me interesa abordar antes este último. Puestos a devolver una respuesta *hard-coded*, puedo empezar con la transformación desde el objeto `Task` y luego ya continuaré el desarrollo de `TaskRepository`.

De hecho tiene sentido esto como refactor en la situación actual, mientras el test está en verde. Así que vamos a ello:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = {
      1 => Task.new(1, 'Write a test that fails')
  }
    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

Esta solución es muy sencilla en Ruby y nos permite hacer pasar el test.

Para el siguiente paso necesitaremos implementar el método `find_all` en el repositorio, por lo que tenemos que cambiar de foco y movernos a su test. De momento, empezamos con un test sencillo:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.find_all.count).to eq(3)
  end
end
```

Para hacerlo pasar necesitamos:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end
end
```

Y como no está implementado en `memory_storage`, pues se lo añadimos:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end
end
```

Esto hace pasar el test, podríamos añadir aquí tests para verificar que las tareas almacenadas son las que hemos guardado. Después de toquetear un poco:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(1, 'Task Description')
    @task_repository.store Task.new(2, 'Another Task')
    @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    tasks = @task_repository.find_all

    expect(tasks.count).to eq(3)
    expect(tasks[1]).to eq(examples[0])
    expect(tasks[2]).to eq(examples[1])
    expect(tasks[3]).to eq(examples[2])
  end

end
```

Con lo que ya tendríamos lo que necesitamos en el repositorio. Por tanto, podemos introducir su uso en el código de producción después de recuperar el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @task_repository.find_all

    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

Del mismo modo que hicimos en la historia anterior, ahora sería el momento de extraer la lógica de negocio que contiene el controlador a un caso de uso. Hay que recordar que la condición es que sea el controlador quien decida la representación que necesita.

Seguiremos el mismo procedimiento que antes, extrayendo un método privado con la funcionalidad que vamos a mover al caso de uso. Aquí hemos dado un salto bastante grande de código, implementando la estrategia de transformación mediante un **block**.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end

end
```

Es ahora cuando creamos el caso de uso:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end
  
  def execute

  end
end
```

Y lo usamos dentro del código.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Con estos cambios el test pasa. La ejecución del caso de uso no tiene ningún efecto en el test, así que vamos a mover el código con los siguientes pasos:

Primero, copiamos el método privado `get_tasks_list` en el `execute` del caso de uso:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end

  def execute
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Ejecutamos el test para asegurarnos de que este cambio no tiene efectos indeseados. Ahora quitamos la llamada al método privado y volvemos a probar:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    
    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Con esto ya nos aseguramos de que es el caso de uso el que ejecuta la acción y, por tanto, está haciendo que el test siga pasando.

Sólo nos queda borrar el método privado.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

Y ya está. La segunda historia de usuario está implementada. Nos queda todavía un poco de refactor. Vamos a inyectar el caso de uso que acabamos de crear. Por otro lado, dejaremos aún la dependencia de `TaskRepository` porque es previsible que la necesitemos de nuevo.


```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

Y aplicamos esto en el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @task_repository
end

# ...
```

Ruby es bastante conciso, aún así, voy a hacer algún refactor en el test de aceptación extrayendo a métodos las llamadas a la API:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    
    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

## Marcar una tarea completada

La última funcionalidad que vamos a implementar es marcar una tarea como completada. Nos toca seguir los pasos que hemos realizado hasta ahora:

* Añadir un ejemplo al test de aceptación
* Implementar la funcionalidad en el controlador
* Extraerla a un caso de uso

Si necesitamos desarrollar algo nuevo en algún objeto, como ha ocurrido con el `TaskRepository`, lo hacemos con el test de aceptación en verde, de modo que luego podamos usarlo sin problemas en el código.

A> Es la principal diferencia con *outside-in mockista*: en TDD clásico sólo puede estar fallando un test cada vez, para que nos guíe en aquello que tenemos que implementar.

Así que vamos allá. Empecemos con el test de aceptación que, gracias a los refactors anteriores, debería ser fácil de escribir. Aquí está:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  # ...
  
  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

El principal punto de interés en este test es que vamos a comprobar que ha funcionado recuperando la lista y viendo si ya se representa la tarea como marcada. En muchos aspectos, podríamos considerar que este test sería suficiente para validar toda la funcionalidad de la lista ya que para que para llegar al resultado final todas las demás acciones, que hemos desarrollado con otros tests, funcionan.

Así que vamos a empezar a añadir código de producción hasta lograr que el test pase. Por supuesto, el primer problema es que no hay una ruta ni un controlador asociado.

Con este primer paso conseguimos resolver este problema y el fallo del test ya tiene que ver con el contenido de la respuesta.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  #...

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Este es el error:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[√] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

Y este error ya es que la tarea completada aparece sin marcar, que es exactamente donde queremos estar.

Una forma de solucionarlo es con este código:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.id == 1 ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Y este código hace pasar nuestro test actual. Sin embargo, hace fallar el test anterior de obtener todas las tareas ya que en ese test se asume que no hay ninguna completada.

Por supuesto, lo que necesitamos es que una tarea pueda decir que está completada. Necesitamos añadir algún comportamiento en `Task`, pero también que los tests de aceptación anteriores pasen. Por tanto, vamos a quitar este test temporalmente, revertir este último cambio y trabajar en añadir en `Task` la capacidad de ser marcada como completa.

De momento, me basta con anular la última aserción, que es la que controla el cambio de comportamiento en `Task`:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  #...

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    # expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end

```

Y también tengo que neutralizar el cambio en el código de producción, temporalmente:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Vamos a ver entonces cómo marcar tareas completadas:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end
end
```

Esto nos basta para introducir la propiedad, iniciarla como `false`, y exponer un método para acceder a ella.

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end
end
```

Por otra parte, necesitamos poder marcar la tarea como completada:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end

  it 'should be able to be completed' do
    task = Task.new 1, 'Task Description'
    task.mark_completed
    expect(task.completed).to be_truthy
  end
end
```

Lo cual es bastante sencillo de lograr:

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end

  def mark_completed
    @completed = true
  end
end
```

Por esta parte ya tenemos lo que necesitamos.

Ahora, vamos a hacer un refactor para usar algunas de estas capacidades. Con este refactor mantenemos el comportamiento actual y estamos preparados para atender al cambio importante:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  # ...
end
```

Así que recuperamos el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

Que falla por el motivo deseado. No deja de tener cierta gracia que nos interese que fallen cosas por una buena razón:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[√] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

Ahora es cuando implementamos una solución tentativa:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    task = Task.new 1, 'Write a test that fails'
    task.mark_completed
    
    @task_repository.store task

    [200]
  end
end
```

Y esto hace pasar el test. Obviamente necesitamos recuperar primero la tarea para poder actualizarla, pero es algo que no tenemos todavía en nuestro `TaskRepository`. Pero como tenemos todos los tests pasando podemos añadir la funcionalidad.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  # ...

  it 'should retrieve a task by id' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    task = @task_repository.retrieve 1

    expect(task).to eq(examples[0])
  end
end
```

Lo implementamos así:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end

  def retrieve(task_id)
    @storage.retrieve task_id
  end
end
```

Junto con:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end

  def retrieve(object_id)
    @objects[object_id]
  end
end
```

Ahora posamos usarlo en nuestra implementación, reemplazando la asignación directa de `task`, que tenemos ahora.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task

    [200]
  end
end
```

Y ya casi estamos. El test de aceptación sigue pasando. Lo único que nos queda es introducir el caso de uso, para lo que seguimos el proceso de refactor que ya conocemos. Primero extraemos la funcionalidad a un método privado.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id

    [200]
  end

  def self.mark_task_completed(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

Introducimos la nueva clase, que simplemente usa el mismo código que ya está testado.

```ruby
class MarkTaskCompletedHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

Y ahora, introducimos su uso. Como esta acción es idempotente, podemos hacer esto de modo que probamos si funciona antes de eliminar el código que hemos movido:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id
    
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository
    @mark_task_completed.execute task_id
    [200]
  end

  # ...
end
```

Y el test sigue pasando, como era de esperar. Así que podemos eliminar el método extraído antes. Después tendremos que cambiar la construcción para inyectar el caso de uso. Pero vamos por partes:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end


  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id
    
    [200]
  end

end
```

El cambio de la construcción lo vamos a dirigir desde el test, iniciando la aplicación con los servicios que realmente necesita

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @mark_task_completed
end

# ...

```

Los test fallarán estrepitosamente, pero el cambio es fácil de aplicar. Así queda la aplicación:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  
  def initialize(add_task_handler, get_tasks_list_handler, mark_task_completed)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = mark_task_completed
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id

    [200]
  end
end
```

## Qué hemos aprendido con esta kata

* Es perfectamente posible aplicar un enfoque *outside-in* con la metodología clásica de TDD.
* La modalidad *outside-in clásica* require que tengamos los tests en verde para introducir el diseño porque lo hacemos en la fase de refactor.
* En algunos momentos podríamos necesitar dobles de test, aunque preferiremos usar implementaciones *fake* o específicas para test (como los repositorios en memoria), o en su caso *stubs* antes que *mocks*.


