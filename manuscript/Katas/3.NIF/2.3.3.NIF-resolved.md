# Resolviendo la Kata NIF

En este kata vamos a orientarnos en una estrategia que aborde primero los *sad paths*, es decir, vamos a tratar primero los casos que provocarían un error. De este modo, primero desarrollaremos la validación de la estructura del input, para pasar después al del algoritmo.

Es habitual que las katas obvien temas como las validaciones, pero en este caso hemos preferido hacer un ejemplo que es más realista, en el sentido de que es una situación con la que lidiamos habitualmente. En el código de un proyecto en producción es fundamental la validación de datos de entrada y no está de más practicar con un ejercicio que pone su foco casi exclusivamente en ello.

Aparte, veremos un par de técnicas interesantes para transformar una interfaz pública sin romper los tests.

## Enunciado de la kata

Crear un clase Nif, que será un Value Object para representar el Número de Identificación Fiscal de España. Es una combinación de una cadena de ocho caracteres numéricos, con una letra final que actúa como carácter de control.

Esta letra de control se obtiene calculando el resto de dividir la parte numérica del NIF entre 23 (mod 23). El resultado nos indica la fila en la que consultar la letra de control de la siguiente tabla. En esta tabla he incluido también ejemplos sencillos de NIF válidos para que los puedas usar en los tests.

| Parte numérica | Resto | Letra | Ejemplo NIF válido |
|----|------|-------|----|
| 00000023 | 0 | T | 00000023T |
| 00000024 | 1 | R | 00000024R |
| 00000025 | 2 | W | 00000025W |
| 00000026 | 3 | A | 00000026A |
| 00000027 | 4 | G | 00000027G |
| 00000028 | 5 | M | 00000028M |
| 00000029 | 6 | Y | 00000029Y |
| 00000030 | 7 | F | 00000030F |
| 00000031 | 8 | P | 00000031P |
| 00000032 | 9 | D | 00000032D |
| 00000033 | 10 | X | 00000033X |
| 00000034 | 11 | B | 00000034B |
| 00000035 | 12 | N | 00000035N |
| 00000036 | 13 | J | 00000036J |
| 00000037 | 14 | Z | 00000037Z |
| 00000038 | 15 | S | 00000038S |
| 00000039 | 16 | Q | 00000039Q |
| 00000040 | 17 | V | 00000040V |
| 00000041 | 18 | H | 00000041H |
| 00000042 | 19 | L | 00000042L |
| 00000043 | 20 | C | 00000043C |
| 00000044 | 21 | K | 00000044K |
| 00000045 | 22 | E | 00000045E |

Puedes crear NIF inválidos simplemente escogiendo una parte numérica y la letra que no le corresponde.

| Ejemplo inválido |
|----|
| 00000000S |
| 00000001M |
| 00000002H |
| 00000003Q |
| 00000004E |

Hay una excepción: los NIF para extranjeras (o NIE) pueden empezar por las letras `X`, `Y` o `Z`, que a los efectos de los cálculos se reemplazan por los números `0`, `1` y `2`, respectivamente. En ese caso `X0000000T` equivale a `00000000T`.

Para evitar confusiones se han excluido las letras `U`, `I`, `O` y `Ñ`.

Un cadena que empieza por una letra distinta de `X`, `Y`, `Z`, o que contenga caracteres alfabéticos en las posiciones centrales también es inválida.

## Lenguaje y enfoque

Esta kata la vamos a resolver en Go, por lo que vamos a matizar un poco su resultado. En este ejemplo vamos a crear un tipo de dato `Nif`, que será básicamente un `string`, y una función factoría `NewNif` que nos permitirá construir NIF validados a partir de un `string` que le pasamos.

Por otro lado, el testing en Go es también un poco particular. Aunque el lenguaje incorpora de forma estándar soporte para realizar tests, no incluye utilidades habituales como `asserts`.

### Disclaimer

Para resolver esta kata me voy a aprovechar de la forma en que Go gestiona los errores. Estos se pueden devolver como una de las respuestas de una función, lo que te obliga a gestionarlos siempre de manera explícita.

Basar tests en mensajes de error no es una buena práctica, porque pueden cambiar con facilidad haciendo fallar los tests aunque no haya realmente una alteración de la funcionalidad. Sin embargo, en esta kata vamos a usar los mensajes de error como una especie de comodín temporal en el que apoyarnos haciendo que cambien de más específicos a más generales. Al acabar el ejercicio manejaremos únicamente dos errores posibles.

## Creando la función constructora

En esta kata nos interesa empezar centrándonos en los *sad paths*, los casos en los que que no vamos a poder usar el argumento pasado a la función constructora. De todas las innumerables combinaciones de string que la función podría recibir vamos primero a dar una respuesta a las que sabemos con seguridad que no nos van a servir porque no se ajustan a los requisitos. Esta respuesta será un error.

Empezaremos rechazando aquellas cadenas que sean demasiado largas, las que tienen más de nueve caracteres. Esto lo podemos describir con este test:

En el archivo **nif/nif_test.go**

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif()
}
```

De momento vamos a ignorar las respuestas de la función simplemente para forzarnos a implementar el mínimo de código.

Como es de suponer el test fallará porque no compila. Así que implementamos el código mínimo necesario, que puede ser tan pequeño como éste:

Archivo **nif/nif.go**

```go
package nif

func NewNif() {

}
```

Con esto ya logramos una base sobre la que construir.

Ahora podemos avanzar un paso más. La función debería aceptar un parámetro:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif("01234567891011")
}
```

Volvemos a hacer pasar el test con:

```go
package nif

func NewNif(candidate string) {

}
```

Y, finalmente, devolver:

* el NIF cuando el que hemos pasado es válido.
* un error en caso de no se pueda. 

En **Go** una función puede devolver varios valores y, por convención, se devuelven también los errores como último valor devuelto.

Esto proporciona una flexibilidad que no es habitual encontrar en otros lenguajes y nos deja jugar con algunas ideas que son como mínimo curiosas. Por ejemplo, nosotras vamos a ignorar de momento la respuesta de la función y centrarnos sólo en los errores. Nuestro próximo test va a pedir que la función devuelva sólo el error sin hacer nada con él. El `if` es, de momento, para que el compilador no proteste.

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err != nil {}
}
```

Este test nos indica que debemos devolver algo, así que por ahora indicamos que vamos a devolver un error, que puede ser `nil`.

```go
package nif

func NewNif(candidate string) error {
	return nil
}
```

Avancemos un paso más esperando que se produzca un error determinado cuando se cumple la circunstancia definida por el test, que la cadena es demasiado larga, y con lo que tendremos ya un primer test en condiciones:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}
```

De nuevo fallará el test y para hacerlo pasar devolvemos incondicionalmente el error:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	return errors.New("too long")
}
```

Y con esto ya hemos hecho que nuestro primer test esté completo y pase. Podríamos ser un poco más estrictas en el manejo de la respuesta para contemplar el caso de que `err` sea `nil`, pero de momento es algo que no nos tiene que afectar.

En este punto me gustaría llamar tu atención al hecho de que no estamos resolviendo nada todavía: el error se devuelve de manera incondicional, por lo que estamos retrasando esta validación para más tarde.

## Implementar la primera validación

Nuestro segundo test tiene como objetivo forzar la implementación de la validación que acabamos de posponer. Puede sonar un poco extraño, pero nos muestra que uno de los grandes beneficios de TDD es el hecho de poder posponer decisiones. Al hacerlo, tendremos un poco más de información, lo que siempre es una ventaja.

El test es muy similar al anterior:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}

func TestShouldFailWhenStringIsTooShort(t *testing.T) {
	err := NewNif("0123456")

	if err.Error() != "too short" {
		t.Errorf("Expected too short, got %s", err.Error())
	}
}
```

Este test ya nos obliga a actuar de manera diferente en cada caso, así que vamos a implementar la validación que limita los string demasiado largos:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	return errors.New("too short")
}
```

Vuelvo a señalar que en este momento lo que dice el test no lo estamos implementando ahora. Lo haremos en el siguiente ciclo, pero el test se cumple al devolver el error esperado de forma incondicional.

No hay mucho más que podamos hacer en el código de producción, pero al fijarnos en los tests podemos ver que sería posible unificar un poco su estructura. Al fin y al cabo vamos a hacer una serie de ellos en los que pasamos un valor y esperamos un error determinado como respuesta.

## Un test para dominarlos a todos

En **Go** existe una estructura de test similar a la que en otros lenguajes nos proporciona el uso de *Data Providers*: `Table Test`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
``` 


Con esto conseguimos que ahora sea muy fácil y rápido añadir tests, sobre todo si son de la misma familia, como en este caso en el que pasamos cadenas candidatas inválidas y chequeamos por el error. Además, si hacemos cambios en la interfaz de la constructora sólo tenemos un lugar en donde aplicarlos.

Con esto, tendríamos ya todo preparado para seguir desarrollando.

## Completar la validación de la longitud y empezar a examinar la estructura

Con los dos tests anteriores verificamos si la cadena que vamos a examinar cumple la especificación de tener exactamente nueve caracteres, aunque de momento eso no está implementado. Lo haremos ahora.

Sin embargo, puede que te preguntes por qué no testear simplemente que la función rechaza los `strings` que no la cumplan, algo que podríamos hacer en un único test.

La razón es que en realidad hay dos posibles formas de que no se cumpla la especificación: el `string` tiene más de nueve caracteres o el `string` tiene menos. Si hacemos un sólo test elegiremos uno de los dos casos, con lo cual no estamos garantizando que se cumpla el otro.

En este ejemplo concreto en que hay un único valor que nos interesa podríamos plantear la disyuntiva entre `strings` con longitud nueve y `strings` con longitud distinta de nueve. Sin embargo, es frecuente que tengamos que trabajar con intervalos de valores que, además, pueden estar abiertos o cerrados. En esa situación la estrategia de dos, o incluso más tests, es muchísimo más segura.

En cualquier caso, en el punto en el que estamos, para mover el desarrollo necesitamos añadir otro requisito en forma de test. Los dos tests existentes nos definen la longitud válida del `string`. El siguiente test pregunta por su estructura.

Y con el refactor que acabamos de hacer añadir un test es tremendamente sencillo.

Empezaremos por el principio. Los NIF válidos comienzan con un número, excepto un subconjunto de ellos que lo hace por alguna de las letras `X`, `Y` y `Z`. Una forma de definir el test es de la siguiente forma:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Para hacer pasar el test, resolvemos primero el problema pendiente del anterior:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	if len(candidate) < 9 {
		return errors.New("too short")
	}

	return errors.New("bad start format")
}
```

Aquí tenemos una oportunidad de refactor bastante clara que consistiría en unir las condicionales que evalúan la longitud del `string`. Sin embargo, esa va a hacer que el test falle ya que al menos tendríamos que cambiar un mensaje de error.

### La vía no muy limpia de cambiar a la vez test y código de producción

Una posibilidad es "saltarnos" temporalmente la condición de que el refactor sea con los tests en verde y hacer cambios a la vez en prod y test. Veamos qué pasa.

Lo primero sería cambiar el test para esperar un mensaje de error distinto, que será más genérico e igual para todos los casos que queremos consolidar en este paso:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Esto hará fallar el test. Cosa que se puede arreglar cambiando el código de producción del mismo modo:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

El test vuelve a pasar y estamos listas para el refactor. Pero no vamos a hacer eso.

### La vía segura

Otra opción es hacer un refactor temporal en el test para hacerlo más tolerante. Simplemente hacemos que sea posible devolver un error más genérico aparte del error específico.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Este cambio nos permite ahora hacer el cambio en producción sin romper nada:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad end format")
}
```

El test sigue pasando y ahora sí podemos hacer el refactor.

## Unificar la validación por longitud del `string`


Unificar las condicionales es fácil en este momento. Este es el primer paso, que incluyo aquí para tener un modelo de cómo hacer esto en caso de que fuese un intervalo de longitudes válidas.

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 || len(candidate) < 9 {
		return errors.New("bad format")
	}
	
	return errors.New("bad start format")
}
```

Pero se puede hacer mejor:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) != 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

Y un poco más expresivo:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	const maxlength = 9
	
	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

Finalmente, un nuevo refactor del test para contemplar estos cambios. Retiramos nuestro cambio temporal aunque es posible que tengamos que volver a utilizarlo en el futuro.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

```

Fíjate que hemos podido hacer todos estos cambios sin que fallaran los tests.

## Avanzando en la estructura

El código está bastante compacto, así que vamos a añadir un nuevo test que nos permita avanzar con la validez de la estructura. El fragmento central del NIF está compuesto sólo por números, exactamente siete:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Lo lanzamos para asegurarnos de que falla por la razón adecuada. Para hacer pasar el test tenemos que resolver primero el test anterior, por lo que añadiremos código para verificar que el primer símbolo es un número o una letra en el conjunto `X`, `Y` y `Z`. Lo haremos con una expresión regular:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	invalid := regexp.MustCompile(`(?i)^[^0-9XYZ].*`)

	if invalid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

Con este código hacemos pasar el test, pero vamos a hacer un refactor.

## Invertir la condicional

Tiene sentido que en vez de hacer *match* contra una expresión regular que excluya los string no válidos, hagamos *match* contra una expresión que los detecte. Con eso tendremos que invertir la condicional. Lo cierto es que el cambio es bastante pequeño:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

## El final de la estructura

Nos estamos acercando al final de la validación estructural del NIF, necesitamos un test que nos diga cuáles rechazar en función de su último símbolo, lo que nos llevará a resolver el problema que quedaba pendiente del test anterior:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

De las cuatro letras no válidas tomamos la `U` como ejemplo, pero podrían ser la `I`, la `Ñ` y la `O`.

Sin embargo, para hacer pasar el test, lo que hacemos es asegurarnos que el anterior se va a cumplir. Lo más fácil es implementar eso de forma separada:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad middle format")
	}

	return errors.New("invalid end format")
}
```

## Compactando el algoritmo

Con esto pasa el test y nos encontramos con una situación familiar que ya hemos resuelto antes: tenemos que convertir los errores en más genéricos con la ayuda temporal de un control extra en el test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Hacemos el cambio en los mensajes de error en el código de producción:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Ahora unificamos la expresión regular y las condicionales:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}
	
	return errors.New("invalid end format")
}
```

Todavía podemos hacer un cambio pequeño pero importante. La última parte de la expresión regular `.*` está para cumplir el requisito de que se haga match de toda la cadena, pero realmente no necesitamos el cuantificador ya que nos basta un carácter:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Y esto nos revela un detalle, la expresión regular hace *match* únicamente en cadenas de exactamente nueve caracteres, por lo que la validación inicial de la longitud resulta innecesaria:

```
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Tanto camino recorrido para desandarlo. Sin embargo, al principio no sabíamos esto y es ahí donde está el valor del proceso.

Por último, cambiamos el test para reflejar los cambios y volver a quitar nuestro apoyo temporal:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

## Terminando la validación estructural

Necesitamos un nuevo test para terminar la parte de la validación estructural. Los tests existentes nos garantizarían la corrección de los `strings`, pero la siguiente validación ya implica el algoritmo para calcular la letra de control. 

El test que necesitamos ahora controla que no podemos usar un NIF estructuralmente válido, pero en el que la letra de control sea incorrecta. Al enunciar la kata pusimos algunos ejemplos, como `00000000S`. Este es el test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Y he aquí el código que lo hace pasar:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("invalid end format")
	}
	
	return errors.New("bad control letter")
}
```

Y, cómo no, toca refactorizar.

## Compactando la validación

Este refactor es bastante obvio, pero tenemos que volver a proteger el test temporalmente:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Hacemos más general el error para poder unificar las expresiones regulares y las condicionales:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Y hacemos ahora la unificación, mientras los tests siguen pasando:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto terminamos la validación de la estructura y nos quedaría implementar el algoritmo **mod23**. Pero para eso necesitamos un pequeño cambio de enfoque.

## Seamos optimistas

El algoritmo es, de hecho, muy sencillo: obtener un resto (de dividir por 23) y buscar la posición indicada por el resultado en una tabla. Es fácil de implementar en una sola iteración. Sin embargo, vamos a hacerlo más lentamente.

Hasta ahora nuestros tests eran pesimistas porque esperaban ejemplos incorrectos de NIF para poder pasar. Nuestros tests ahora tienen que ser optimistas, es decir, van a esperar que le pasemos ejemplos de NIF válidos.

En este punto introduciremos un cambio. Si recuerdas, de momento sólo estamos devolviendo el error y la interfaz final de la función devolverá el `string` validado como un tipo NIF que vamos a crear para la ocasión.

Es decir, tenemos que cambiar el código para que devuelva algo, y que ese algo sea de un tipo que todavía no existe.

Para hacer este cambio sin romper los tests vamos a hacer una técnica de refactor un tanto rebuscada.

## Cambiando la interfaz pública

En primer lugar, extraemos el cuerpo de `NewNif` a otra función:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	return FullNewNif(candidate)
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Los tests siguen pasando. Ahora introducimos una variable:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto podemos hacer que `FullNewNif` devuelva el `string` sin afectar al test porque queda encapsulado dentro de `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	_, err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Los tests siguen pasando y casi hemos acabado. En el test cambiamos el uso de `NewNif` por `FullNewNif`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := FullNewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Siguen pasando los tests. Ahora la función devuelve los dos parámetros que queríamos y no hemos roto los tests. Podemos eliminar la función `NewNif` original.

```go
package nif

import (
	"errors"
	"regexp"
)

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Y usar las herramientas del IDE para cambiar el nombre de la función `FullNewNif` a `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

## Ahora sí

Nuestro objetivo ahora es empujar la implementación el algoritmo **mod23**. Esta vez los tests esperan que la cadena sea válida. Además, queremos forzar que se devuelva el tipo `Nif` en lugar de `string`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)
			
			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}
			
			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

En un primer paso cambiamos el código de producción para introducir y usar el tipo `Nif`:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return "", errors.New("bad control letter")
}
```

Ahora el test estará fallando porque no hemos validado nada todavía. Para hacerlo pasar añadimos un condicional:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Una nota sobre **Go** es que los tipos *custom* no pueden tener valor `nil`, sino vacío. Por eso en caso de error devolvemos `string` vacío.

## Avanzando el algoritmo

De momento no hay muchos motivos para hacer refactor, así que vamos a introducir un test que nos ayude a avanzar un poco. En principio, queremos lograr que nos impulse a separar la parte numérica de la letra de control.

Una posibilidad sería testear otro NIF que acabe con la letra `T`, como el `00000046T`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
		{"should accept mod23 being 0 letter T", "00000046T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Para hacer pasar el test, podemos hacer esta implementación sencilla:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	if candidate == "00000046T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y ahora empezamos a refactorizar.

## Más refactor

En el código de producción podemos ver lo que hay de diferente y de común entre los ejemplos. En ambos la letra de control es `T` y la parte numérica es divisible entre 23, por lo que su **mod23** será 0.

Ahora podemos hacer el refactor. Un primer paso.

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	if control == "T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y, después de ver pasar los tests, el segundo paso:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23
	
	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Con este cambio los tests pasan y acepta todos los NIF válidos acabados en `T`.

## Validando más letras de control

En este tipo de algoritmos no tiene mucho sentido intentar validar todas las letras de control, pero podemos introducir una más para forzarnos a entender cómo debería evolucionar el código ahora. Probaremos con una nueva letra:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Ya tenemos este test fallando, así que vamos a hacer una implementación muy sencilla:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	if control == "R" && modulus == 1 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Esto ya nos da una idea de por dónde van los tiros: un mapa entre letras de control y el resto al dividir por 23. Sin embargo, es frecuente que los `strings` puedan funcionar como `arrays` en muchos lenguajes, por lo que nos basta tener un `string` con todas las letras de control ordenadas y acceder a la letra en la posición indicada por el módulo para saber cual es la correcta.

## Un refactor para más simplicidad

Primero implementamos una versión simple de esta idea:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	controlMap := "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Ya tenemos una primera versión. Luego añadiremos la lista completa de letras, pero podemos intentar arreglar un poco el código actual. Primero hacemos que `controlMap` sea constante:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	const controlMap = "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

En realidad podríamos extraer toda la parte del cálculo del módulo a otra función. Primero reorganizamos el código para controlar mejor la extracción:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]
	
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	shouldBe := controlMap[modulus]
	
	if control == shouldBe {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Recuerda verificar que pasan los tests. Ahora extraemos la función:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]

	if control == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	
	return controlMap[modulus]
}
```

Y podemos compactar el código un poco más, mientras que añadimos las demás letras de control. A primera vista parece "trampa", pero en el fondo no es más que generalizar un algoritmo que se podría enunciar como "toma la letra que hay en la posición dada por el **mod23** de la parte numérica".

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Con esto ya podemos validar todos los NIF, excepto los NIE, que empiezan por las letras `X`, `Y` ó `Z`.

## Dar soporte a NIE

Ahora que hemos implementado el algoritmo general vamos a tratar sus excepciones, que no son tanto. Los NIE comienzan con una letra que a efectos del cálculo se reemplaza con un número.

El test que parece más evidente en este punto es el siguiente:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

El caso `X0000023T` es equivalente a `00000023T`, ¿afectará eso al resultado del test?

Ejecutamos el test y… ¿sorpresa? El test pasa. Esto ocurre porque la conversión que hacemos en esta línea genera un error que actualmente estamos ignorando, pero permite que la parte numérica siga siendo equivalente a 23, cuyo **mod23** es 0 y le corresponde igualmente la letra `T`.

```go
	numeric, _ := strconv.Atoi(candidate[0:8])
```

En otro lenguajes la conversión no falla, pero asume la X como 0 al realizar la conversión.

En cualquier caso eso nos abre dos posible caminos:

* anular este test y refactorizar el código de producción para tratar el error y que el test falle cuando lo volvamos a incluir
* probar otro ejemplo que sí pueda fallar (`Y0000000Z`) y hacer el cambio después 

Posiblemente para este caso la segunda opción sería más que suficiente ya que con nuestras validaciones estructurales ya garantizaríamos que el error no tiene posibilidad de aparecer una vez que la función esté completamente desarrollada.

Sin embargo, podría ser interesante introducir la gestión del error. Manejar los errores, incluyendo los que *nunca podrían llegar a pasar*, es siempre una buena práctica.

Así que, anulemos el test e introduzcamos un refactor para manejar el error:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		//{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Aquí el refactor. En este caso, gestiono el error provocando un `panic`, que no es la mejor manera de gestionar un error, pero que nos permite hacer que el test pueda fallar y obligarnos a implementar la solución.

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, err := strconv.Atoi(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}
	
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Al ejecutar los tests, comprobamos que siguen en verde. Pero si reactivamos el último test vemos cómo falla:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Y esto ya nos obliga a introducir un tratamiento para estos casos. Básicamente es reemplazar la `X` por `0`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	if string(candidate[0]) == "X" {
		numPart = strings.Replace(numPart, "X", "0", 1)
	}

	numeric, err := strconv.Atoi(numPart)

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Se puede refactorizar usando un `Replacer`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0")
	
	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

En este punto podríamos hacer un test para forzarnos a introducir el resto de reemplazos. Es barato, aunque en el fondo no es muy necesario por lo que comentamos antes, podemos interpretar esta parte del algoritmo como "reemplazar las letras iniciales X, Y y Z por los números 0, 1 y 2, respectivamente":

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000000T"},
		{"should accept NIE starting with Y", "Y0000000Z"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Sólo es necesario añadir los pares correspondientes:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0", 
	                          "Y", "1", 
	                          "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Después de un rato de refactor, esta sería una posible solución:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] != controlLetterFor(candidate) {
		return "", errors.New("bad control letter")
	}

	return Nif(candidate), nil
}

func controlLetterFor(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	position, err := controlPosition(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}

	return controlMap[position]
}

func controlPosition(numPart string) (int, error) {
	re := strings.NewReplacer("X", "0", "Y", "1", "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	return numeric % 23, err
}
```

## Qué hemos aprendido con esta kata

* Utilizar sad paths para mover el desarrollo
* Utilizar table tests en Go para reduciendo el coste de añadir nuevos tests
* Una técnica para cambiar los errores devueltos por otro más general sin romper los tests
* Una técnica para cambiar la interfaz pública del código de producción sin romper los tests

## Referencias

* [Is Go object oriented?](https://flaviocopes.com/golang-is-go-object-oriented/)[^fn37]


[^fn37]: https://flaviocopes.com/golang-is-go-object-oriented/
