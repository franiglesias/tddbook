# Outside-in TDD clásico

Es posible seguir una metodología outside-in mientras mantenemos el ciclo de TDD clásico. Como ya sabrás, en esta aproximación el diseño se aplica durante la fase de refactor, por lo que, una vez que hemos desarrollado una versión tosca de la funcionalidad deseada, vamos identificando responsabilidades y extrayéndolas a diferentes objetos con los que vamos componiendo el sistema.

En las katas de estilo clásico que hemos presentado en la segunda parte del libro no hemos llegado a esta fase de extracción a colaboradores, pero sería algo perfectamente posible.De hecho, es un ejercicio recomendable.

Sin embargo, cuando hablamos de outside-in es frecuente que pensemos más bien en proyectos más complejos que los problemas propuestos en las katas. Es decir, el desarrollo de un producto de software real visto desde el punto de vista de sus consumidores.

Nuestro ejemplo de backend de aplicación de lista de tareas estaría en esta categoría. En el capítulo anterior hemos desarrollado el proyecto usando el enfoque *mockista*, cuya característica principal es que partimos de un test de aceptación y vamos *entrando* en cada componente de la aplicación, que desarrollamos con la ayuda de un test unitario, *mockeando* los componentes más internos que aún no hemos desarrollado.

En TDD clásico con frecuencia se hace un diseño *up-front* para tener una idea de los componentes necesarios y luego se desarrolla cada uno de ellos, integrándose después.

Pero outside-in clásico es un poco diferente. Empezaríamos también con un test en el nivel de aceptación y empezaríamos a escribir la lógica que lo hace pasar. En las fases de refactor introduciríamos objetos capaces de hacerse cargo de las diversas responsabilidades que iríamos identificando.

Para este ejemplo escribiremos una nueva versión de nuestra aplicación de lista de tareas, esta vez en Ruby. El framework HTTP será Sinatra y el framework de testing RSpec.

## Planteando el problema

Nuestro punto de partida será igualmente un test de aceptación como consumidoras de la API. En cierto modo, podríamos considerar el sistema como un gran *objeto* con el que nos comunicamos mediante request a sus end points.

Al tratarse de TDD clásico no usaremos mocks, salvo si necesitamos definir un límite de arquitectura. Obviamente para definir este tipo de cosas necesitamos tener algún mínimo de diseño up-front, así que esperamos que en algún momento tendremos casos de uso, entidades de dominio y repositorios.

Este límite de arquitectura en nuestro ejemplo será el repositorio. Como todavía no vamos a definir cuál es la tecnología concreta de persistencia, en su momento lo mockearemos. Después veremos cómo desarrollar una implementación.

### Poniendo en marcha el desarrollo

Mi primera propuesta de test es la siguiente:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

Este test intenta instanciar un objeto `TodoListApp`, que es la clase en la que definiremos la aplicación `Sinatra` que responderá en primera instancia. Requiere instalar `rspec`, si no lo tenemos ya. Y fallará con este error:

```
     NameError:
       uninitialized constant TodoListApp
     # ./spec/todo_list_acceptance_spec.rb:10:in `block (2 levels) in <top (required)>'
```

Que nos indica que no tenemos la clase definida en ningún sitio. Para hacerlo pasar, introduciré la clase en el mismo archivo del test y cuando consiga ponerlo en verde, lo moveré a su ubicación.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

class TodoListApp

end

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

Esto es suficiente para hacer pasar el test, por lo que voy a hacer el refactor más obvio, que es mover `TodoListApp` a un lugar adecuado en el proyecto.

La fase de refactor es la fase en la que tomamos decisiones de diseño en el enfoque clásico. Los controladores pertenecen a la capa de infrastructura, por lo que será allí donde coloque esta clase. Con eso, el test queda así:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end

```

Y verificamos que sigue pasando.

Para el siguiente punto necesito hacer un salto un poco más grande y preparar el cliente que ejecutará las requests contra los end points. Usando rack-test, puedo crear un cliente del api. Puesto que estoy en verde, voy a introducirlo e iniciarlo. Tendremos que instalar `rack-test`.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )
    
  end
end
```

Este refactor no cambia el resultado del test, así que vamos bastante bien.

Ahora vamos a asegurarnos de que podemos hacer una llamada `POST /api/todo` y que alguien nos responde.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

  end
end
```

Ahora el test falla, porque la aplicación no es capaz de enrutar la llamada a ningún método. Es el momento de implementar algo en TodoListApp hasta lograr hacer pasar el test. Esto requerirá introducir e instalar `sinatra`.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base

end
```

Lo cierto es que basta con esto para que el test pase. Necesitamos un poco más de resolución para obligarnos a implementar una acción asociada al endpoint. Por ejemplo:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

    expect(@client.last_response.status).to eq(201)
  end
end
```

Y este test, que ya es un *test de verdad*, nos muestra que no se encuentra la ruta deseada:

```
  1) As a user I want to add a new task to the list
     Failure/Error: expect(@client.last_response.status).to eq(201)

       expected: 201
            got: 404
```

Con lo que ya podemos implementar una acción que responda.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  post '/api/todo' do
    [201]
  end
end
```

Ahora hemos hecho pasar el test, devolviendo una respuesta fija, y ya tenemos la seguridad de que nuestra aplicación está respondiendo al endpoint. Sería el momento de introducir la llamada con su payload, que será la descripción de la nueva tarea.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

  RSpec.describe 'As a user I want to' do

    it "add a new task to the list" do
      todo_application = TodoListApp.new

      @client = Rack::Test::Session.new(
        Rack::MockSession.new(
          todo_application
        )
      )

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

El test no añade nueva información. Si queremos progresar en el desarrollo necesitaremos introducir otro test que cuestione la implementación actual, obligando a hacer un cambio en la dirección de hacer aquello que se espera que haga el test.

Este end point sirve para crear tareas y guardarlas en la lista, lo que quiere decir que produce un efecto (*side effect*) en el sistema. Es un comando y no ofrece ninguna respuesta. Para testearlo tenemos que comprobar el efecto verificando que en algún lugar hay una tarea creada.

Una posibilidad es asumir que la tarea se persistirá en un `TaskRepository`, que sería un colaborador de `TodoListApp`. Los repositorios son objetos en los límites de arquitectura y se basan en una tecnología concreta. Esto presupone un cierto nivel de diseño previo, pero creo que es un compromiso aceptable dentro del enfoque clásico.

Esto implica modifica la forma en que se instancia `TodoListApp`, de modo que podamos pasarle colaboradores. Así que antes de nada, vamos a refactorizar el test de modo que la creación de nuevos ejemplos sea más fácil y el test más expresivo.

Quedaría algo así:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

Con este rediseño el test sigue pasando. Ahora, tenemos que introducir un doble del repositorio. Lo mínimo necesario para forzarnos a crear algo es:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

Con lo que tendríamos que introducir la definición de la clase. De momento, lo haremos en el mismo archivo.

```ruby

# ...

class TaskRepository
  
end

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

# ...

```

Y se lo pasamos a `TodoListApp` como parámetro de construcción.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

class TaskRepository

end

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    [201]
  end
end
```

En principio estos cambios no afectan al resultado del test.  Así que vamos a mover `TaskRepository` a su sitio, en la capa de dominio.

A continuación, necesitamos definir el efecto que esperamos obtener, lo cual hacemos fijando una expectativa sobre el mensaje que vamos a enviar a task repository.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
  require_relative '../src/domain/task_repository'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do

      expect(@task_repository)
        .to receive(:store)
              .with(instance_of(Task))

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

El test falla inicialmente porque hemos introducido `Task`, así que lo añadimos ya en su ubicación en la capa de dominio, porque lo necesitaremos enseguida. Al hacerlo, conseguimos que el test falle por el motivo adecuado:

```
1) As a user I want to add a new task to the list
   Failure/Error:
     expect(@task_repository)
       .to receive(:store)
             .with(instance_of(Task))

     (Double TaskRepository).store(an_instance_of(Task))
         expected: 1 time with arguments: (an_instance_of(Task))
         received: 0 times
```

Añadiendo este código en TodoListApp, hacemos que pase el test.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new
    @task_repository.store(task)
    [201]
  end
end
```

Ahora necesitamos que un nuevo test nos pida implementar que se instancia una `Task` con los valores deseados. Esto es, queremos que Task se inicie con el id 1 y la descripción que le pasamos. Para que el test funcione tenemos que implementar una inicialización en Task, que aún no tenemos y alguna forma de comparar objetos `Task`.

En Ruby, dos objetos son iguales si tienen el mismo identificador interno de objeto, por lo que la Task que creemos en el test como esperada y la que se genere en el código de producción nunca serán iguales.Para verificarlo tenemos varias opciones, aunque una de las más sencillas es introducir un matcher en el test que nos permita hacer alguna comparación.

Por otro lado, tenemos que implementar alguna manera de inicializar `Task`. Esta creación puede ser cubierta por el propio test de aceptación. Otro modo de hacerlo sería desarrollando `Task` con un test unitario, pero la verdad es que, de momento, no lo veo necesario.

Al introducir esto en el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Empezará a fallar, por lo que tenemos que implementar la inicialización:

```ruby
class Task
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

El test falla ahora porque en el `TodoListApp` no estamos inicializando bien `Task` ya que no le pasábamos argumentos. Con este pequeño cambio, el test ya pasa.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new 1, 'Write a test that fails'
    @task_repository.store(task)
    [201]
  end
end
```

Se puede decir que aquí estamos usando constantes para satisfacer el test, por lo que tenemos que evolucionar el código y obtener una implementación más flexible. Empezaré con un pequeño refactor que ponga de manifiesto lo que tenemos que lograr a continuación.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task_id = 1
    task_description = 'Write a test that fails'
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Así de simple, tenemos que obtener valores para las variables que acabamos de introducir. Pero ahora mismo no lo estamos comprobando. Es el momento de introducir un matcher.

```ruby
RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end
```

Para usarlo, cambiaremos el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

En este momento el test no pasará porque Task no expone métodos para acceder a sus propiedades, por lo que añadiremos `attr_reader`:

```ruby
class Task
  attr_reader :description, :id
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

Y con esto el test pasa.

`task_description` viene en la payload de la request. Puesto que ya está definida en el test ahora mismo podríamos simplemente usarla.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']
    
    task_id = 1
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

En cuanto al id de task, necesitaremos un generador de identidades. En nuestro diseño hemos puesto esta responsabilidad en `TaskRepository`, que tendría un método *next_id*. En este caso, tendremos que especificarlo en el test mediante un stub.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Tal y como está el código de producción el test pasa, por lo que no nos dice qué tendríamos que hacer a continuación, así que voy a hacer una pequeña trampa y forzar un fallo del test:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = 0
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Ahora sí tiene sentido introducir la llamada a next_id:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = @task_repository.next_id
	
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

## Extracción del caso de uso

Ahora el test ya pasa y podríamos decir que la implementación del end point está completa. Sin embargo, tenemos varios problemas:

* TaskRepository es un mock. Sabemos que interfaz debería tener, pero no tenemos ninguna implementación concreta que pueda funcionar en producción.
* En el controlador hay un montón de lógica de negocio que no debería estar ahí.
* De hecho tenemos objetos de dominio en el controlador: Task y TaskRepostory.

En resumen, ahora mismo, el controlador está haciendo más cosas de las debidas. Además de su tarea como controlador, que es gestionar la request que viene del exterior, está haciendo tareas de la capa de aplicación, coordinando objetos del dominio.

Por tanto, tendríamos que extraer esta parte de la implementación a un nuevo objeto, que será el caso de uso `AddTaskHandler`.

Lo primero que hago es extraer la funcionalidad a un método privado

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private
  
  def add_task(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Crearé una clase AddTaskHandler en la capa de aplicación que encapsule la misma funcionalidad:

```ruby
class AddTaskHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Y reemplazo la implementación del método por una llamada:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private

  def add_task(task_description)
    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
  end
end
```

Hago un inline del método:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
    [201]
  end
end
```

Y refactorizo un poco la solución, moviendo la inicialización al constructor y eliminando alguna variable tempora:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
    @add_task_handler = AddTaskHandler.new @task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    
    @add_task_handler.execute payload['task']
    
    [201]
  end
end
```

El siguiente paso es inyectar la dependencia de AddTaskHandler en lugar de la del repositorio. Para ello cambio primero el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)
  @add_task_handler = AddTaskHandler.new @task_repository
  TodoListApp.new @add_task_handler
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Esto hará que el test falle porque el código de producción sigue esperando al repositorio como dependencia, así que lo cambiamos de este modo:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end
end
```

Y ya tenemos esta parte resuelta.

## Implementando un repositorio

Para arrancar el desarrollo hemos empezado con un `TaskRepository` que es un mock. Hemos introducido una clase vacía para poder doblarla, pero esta version *real* no puede recibir mensajes siquiera. Esto ha sido una licencia que me he permitido para no empezar a desarrollar *desde dentro*, creando componentes de la capa de dominio como este repositorio, antes de saber cómo iban a ser usados.

El repositorio es uno de esos objetos que viven en el límite de arquitectura, por así decir, por lo que es bastante aceptable usar un doble. Sin embargo, ahora vamos a tratar de implementar una versión que pueda servirnos para testear.

En Ruby no tenemos el concepto de interfaz explícita. Esto no es un obstáculo para tener diversas implementaciones de repositorio que podamos usar en distintos entornos. Así, por ejemplo, para tests unitarios podríamos usar un repositorio en memoria, mientras que para pruebas de aceptación es posible que necesitemos una persistencia más duradera.

Esto supone un pequeño problema si consideramos que `TaskRepository` es un objeto del dominio, por lo que no queremos tener implementaciones concretas en esta capa. Una forma sencilla de hacerlo es mediante composición: en dominio tendríamos una clase `TaskRepository` que simplemente delegaría en la implementación concreta que inyectemos. Este es el enfoque que vamos a adoptar en este ejemplo, implementando las versiones del repositorio que puedan ser necesarias a partir de un test unitario extrayendo las implementaciones a partir de una genérica.

En esta ocasión empezamos por la capacidad del repositorio de atender un mensaje `next_id`, que debería ser 1 cuando el repositorio está vacío.

```ruby
require 'rspec'

describe 'TaskRepository' do
    it 'should provide empty collection of tasks' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end
end
```

Este método aún no existe y el test fallará. Implementamos una versión inicial.

```ruby
class TaskRepository
  def next_id
    1
  end
end
```

Con el test en verde, vamos a hacer un refactor. `next_id `debería proporcionarnos un número que es el resultado de sumar uno a la cantidad de tareas almacenada. Así que vamos a representar esto en código primero.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end
  def next_id
    @tasks.count + 1
  end
end
```

Lo suyo sería poder añadir elementos y ver si las cosas realmente funcionan, así que vamos a permitir que el repositorio se pueda inicializar con algún contenido.

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end
end
```

Con esto, podemos testear que si iniciamos el repositorio con algún elemento nos devuelve el identificador correcto. Por ejemplo, así:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'
      
      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Esto ya debería ser suficiente para fiarnos de `next_id`. Puede que estés pensando que la generación de identidades con este algoritmo no es precisamente robusta, pero de momento nos llega para el ejemplo. En cualquier caso, podríamos implementar cualquier otra estrategia.

Ahora podríamos usar `next_id` como una manera indirecta de saber si hemos añadido tareas en el repositorio, por lo que ya podemos testear el método `store`.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'

      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end


    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

De momento, el test falla porque no tenemos un método que atienda el mensaje `store`, así que lo añadimos es implementamos la solución más simple:

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Que, por lo demás, es suficiente para hacer pasar el test. El último test se superpone al último test de `next_id`, así que lo vamos a quitar.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Y también podemos quitar la inicialización, ya que no la necesitamos realmente.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Podríamos asegurarnos de que podemos introducir más tareas:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end

    it 'should add several tasks' do
      task_repository = TaskRepository.new

      task_repository.store Task.new(task_repository.next_id, 'Task Description')
      task_repository.store Task.new(task_repository.next_id, 'Another Task')
      task_repository.store Task.new(task_repository.next_id, 'Third Task')

      expect(task_repository.next_id).to eq(4)
    end
end
```

Puesto que queremos separar la tecnología concreta de persistencia, usaré estos tests para extraer un repositorio en memoria. Nos queda así:

```ruby
require_relative '../infrastructure/persistence/memory_storage'

class TaskRepository
  def initialize
    @storage = MemoryStorage.new
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end
end
```

Ahora podemos inyectarlo, para ello modificamos primero el test:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
  before() do
    @task_repository = TaskRepository.new
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(@task_repository.next_id, 'Task Description')
    @task_repository.store Task.new(@task_repository.next_id, 'Another Task')
    @task_repository.store Task.new(@task_repository.next_id, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end
end
```

Y ahora que sólo tenemos un lugar para inicializar el repositorio...

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end
	
  # ...
end
```

El test fallará, pero sólo tenemos que hacer este cambio:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

Con este cambio tenemos un `TaskRepository` que podremos configurar para usar distintas tecnologías de persistencia y que podríamos empezar a usar en nuestro test de aceptación.

Un cambio posible es este, aunque luego seguiremos evolucionándolo:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app'
require_relative '../src/infrastructure/persistence/memory_storage'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  TodoListApp.new @add_task_handler
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end
end
```

## Obtener una lista de tareas

